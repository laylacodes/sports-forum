{"version":3,"sources":["discourse/plugins/checklist/discourse/initializers/checklist.js","discourse/plugins/checklist/lib/discourse-markdown/checklist.js"],"sourcesContent":["define(\"discourse/plugins/checklist/discourse/initializers/checklist\", [\"exports\", \"discourse/lib/ajax\", \"discourse/lib/plugin-api\", \"discourse-common/lib/icon-library\", \"discourse-i18n\"], function (_exports, _ajax, _pluginApi, _iconLibrary, _discourseI18n) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.checklistSyntax = checklistSyntax;\n  _exports.default = void 0;\n  function initializePlugin(api) {\n    const siteSettings = api.container.lookup(\"site-settings:main\");\n    if (siteSettings.checklist_enabled) {\n      api.decorateCookedElement(checklistSyntax);\n    }\n  }\n  function removeReadonlyClass(boxes) {\n    boxes.forEach(e => e.classList.remove(\"readonly\"));\n  }\n  function isWhitespaceNode(node) {\n    return node.nodeType === 3 && node.nodeValue.match(/^\\s*$/);\n  }\n  function hasPrecedingContent(node) {\n    let sibling = node.previousSibling;\n    while (sibling) {\n      if (!isWhitespaceNode(sibling)) {\n        return true;\n      }\n      sibling = sibling.previousSibling;\n    }\n    return false;\n  }\n  function addUlClasses(boxes) {\n    boxes.forEach(val => {\n      let parent = val.parentElement;\n      if (parent.nodeName === \"P\" && parent.parentElement.firstElementChild === parent) {\n        parent = parent.parentElement;\n      }\n      if (parent.nodeName === \"LI\" && parent.parentElement.nodeName === \"UL\" && !hasPrecedingContent(val)) {\n        parent.classList.add(\"has-checkbox\");\n        val.classList.add(\"list-item-checkbox\");\n        if (!val.nextSibling) {\n          val.insertAdjacentHTML(\"afterend\", \"&#8203;\"); // Ensure otherwise empty <li> does not collapse height\n        }\n      }\n    });\n  }\n  function checklistSyntax(elem, postDecorator) {\n    const boxes = [...elem.getElementsByClassName(\"chcklst-box\")];\n    addUlClasses(boxes);\n    if (!postDecorator) {\n      return;\n    }\n    const postWidget = postDecorator.widget;\n    const postModel = postDecorator.getModel();\n    if (!postModel.can_edit) {\n      return;\n    }\n    boxes.forEach((val, idx) => {\n      val.onclick = async event => {\n        const box = event.currentTarget;\n        const classList = box.classList;\n        if (classList.contains(\"permanent\") || classList.contains(\"readonly\")) {\n          return;\n        }\n        const newValue = classList.contains(\"checked\") ? \"[ ]\" : \"[x]\";\n        const template = document.createElement(\"template\");\n        template.innerHTML = (0, _iconLibrary.iconHTML)(\"spinner\", {\n          class: \"fa-spin\"\n        });\n        box.insertAdjacentElement(\"afterend\", template.content.firstChild);\n        box.classList.add(\"hidden\");\n        boxes.forEach(e => e.classList.add(\"readonly\"));\n        try {\n          const post = await (0, _ajax.ajax)(`/posts/${postModel.id}`);\n          const blocks = [];\n\n          // Computing offsets where checkbox are not evaluated (i.e. inside\n          // code blocks).\n          [\n          // inline code\n          /`[^`\\n]*\\n?[^`\\n]*`/gm,\n          // multi-line code\n          /^```[^]*?^```/gm,\n          // bbcode\n          /\\[code\\][^]*?\\[\\/code\\]/gm,\n          // italic/bold\n          /_(?=\\S).*?\\S_/gm,\n          // strikethrough\n          /~~(?=\\S).*?\\S~~/gm].forEach(regex => {\n            let match;\n            while ((match = regex.exec(post.raw)) != null) {\n              blocks.push([match.index, match.index + match[0].length]);\n            }\n          });\n          [\n          // italic/bold\n          /([^\\[\\n]|^)\\*\\S.+?\\S\\*(?=[^\\]\\n]|$)/gm].forEach(regex => {\n            let match;\n            while ((match = regex.exec(post.raw)) != null) {\n              // Simulate lookbehind - skip the first character\n              blocks.push([match.index + 1, match.index + match[0].length]);\n            }\n          });\n\n          // make the first run go to index = 0\n          let nth = -1;\n          let found = false;\n          const newRaw = post.raw.replace(/\\[(\\s|\\_|\\-|\\x|\\\\?\\*)?\\]/gi, (match, ignored, off) => {\n            if (found) {\n              return match;\n            }\n            nth += blocks.every(b => b[0] >= off + match.length || off > b[1]);\n            if (nth === idx) {\n              found = true; // Do not replace any further matches\n              return newValue;\n            }\n            return match;\n          });\n          await postModel.save({\n            raw: newRaw,\n            edit_reason: _discourseI18n.default.t(\"checklist.edit_reason\")\n          });\n          postWidget.attrs.isSaving = false;\n          postWidget.scheduleRerender();\n        } finally {\n          removeReadonlyClass(boxes);\n        }\n      };\n    });\n  }\n  var _default = _exports.default = {\n    name: \"checklist\",\n    initialize() {\n      (0, _pluginApi.withPluginApi)(\"0.1\", api => initializePlugin(api));\n    }\n  };\n});","define(\"discourse/plugins/checklist/lib/discourse-markdown/checklist\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  const REGEX = /\\[(\\s?|x|X)\\]/g;\n  function getClasses(str) {\n    switch (str) {\n      case \"x\":\n        return \"checked fa fa-check-square-o fa-fw\";\n      case \"X\":\n        return \"checked permanent fa fa-check-square fa-fw\";\n      default:\n        return \"fa fa-square-o fa-fw\";\n    }\n  }\n  function addCheckbox(result, content, match, state) {\n    const classes = getClasses(match[1]);\n    const checkOpenToken = new state.Token(\"check_open\", \"span\", 1);\n    checkOpenToken.attrs = [[\"class\", `chcklst-box ${classes}`]];\n    result.push(checkOpenToken);\n    const checkCloseToken = new state.Token(\"check_close\", \"span\", -1);\n    result.push(checkCloseToken);\n  }\n  function applyCheckboxes(content, state) {\n    let match;\n    let result = null;\n    let pos = 0;\n    while (match = REGEX.exec(content)) {\n      if (match.index > pos) {\n        result = result || [];\n        const token = new state.Token(\"text\", \"\", 0);\n        token.content = content.slice(pos, match.index);\n        result.push(token);\n      }\n      pos = match.index + match[0].length;\n      result = result || [];\n      addCheckbox(result, content, match, state);\n    }\n    if (result && pos < content.length) {\n      const token = new state.Token(\"text\", \"\", 0);\n      token.content = content.slice(pos);\n      result.push(token);\n    }\n    return result;\n  }\n  function processChecklist(state) {\n    let i,\n      j,\n      l,\n      tokens,\n      token,\n      blockTokens = state.tokens,\n      nesting = 0;\n    for (j = 0, l = blockTokens.length; j < l; j++) {\n      if (blockTokens[j].type !== \"inline\") {\n        continue;\n      }\n      tokens = blockTokens[j].children;\n\n      // We scan from the end, to keep position when new tags are added.\n      // Use reversed logic in links start/end match\n      for (i = tokens.length - 1; i >= 0; i--) {\n        token = tokens[i];\n        nesting += token.nesting;\n        if (token.type === \"text\" && nesting === 0) {\n          const processed = applyCheckboxes(token.content, state);\n          if (processed) {\n            blockTokens[j].children = tokens = state.md.utils.arrayReplaceAt(tokens, i, processed);\n          }\n        }\n      }\n    }\n  }\n  function setup(helper) {\n    helper.registerOptions((opts, siteSettings) => {\n      opts.features[\"checklist\"] = !!siteSettings.checklist_enabled;\n    });\n    helper.allowList([\"span.chcklst-stroked\", \"span.chcklst-box fa fa-square-o fa-fw\", \"span.chcklst-box checked fa fa-check-square-o fa-fw\", \"span.chcklst-box checked permanent fa fa-check-square fa-fw\"]);\n    helper.registerPlugin(md => md.core.ruler.push(\"checklist\", processChecklist));\n  }\n});"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"checklist.js"}