function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/ban-types */
// typed-ember doesn't have types for `@ember/helper` yet
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { capabilities as helperCapabilities, setHelperManager } from '@ember/helper';
export function initialize( /* appInstance */
) {
  // noop.
  // we just want the host app to import this file
  // (because the default manager behavior is in glimmer-vm,
  //  and I don't know how to monkey-patch ESM... (I don't think I'd want to either? (danger!)))
}
export default {
  initialize
};
export class FunctionHelperManager {
  constructor() {
    _defineProperty(this, "capabilities", helperCapabilities('3.23', {
      hasValue: true,
      hasDestroyable: false,
      hasScheduledEffect: false
    }));
  }
  createHelper(fn, args) {
    return {
      fn,
      args
    };
  }
  getValue({
    fn,
    args
  }) {
    if (Object.keys(args.named).length > 0) {
      let argsForFn = [...args.positional, args.named];
      return fn(...argsForFn);
    }
    return fn(...args.positional);
  }
  getDebugName(fn) {
    if (fn.name) {
      return `(helper function ${fn.name})`;
    }
    return '(anonymous helper function)';
  }
}
const FUNCTIONAL_HELPER_MANAGER = new FunctionHelperManager();
setHelperManager(() => FUNCTIONAL_HELPER_MANAGER, Function.prototype);