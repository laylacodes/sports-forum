import { createStorage, getValue, setValue } from 'ember-tracked-storage-polyfill';

function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}

function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}

function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
const ARRAY_GETTER_METHODS = new Set([Symbol.iterator, 'concat', 'entries', 'every', 'fill', 'filter', 'find', 'findIndex', 'flat', 'flatMap', 'forEach', 'includes', 'indexOf', 'join', 'keys', 'lastIndexOf', 'map', 'reduce', 'reduceRight', 'slice', 'some', 'values']);
function convertToInt(prop) {
  if (typeof prop === 'symbol') return null;
  const num = Number(prop);
  if (isNaN(num)) return null;
  return num % 1 === 0 ? num : null;
}
var _collection = /*#__PURE__*/new WeakMap();
var _storages = /*#__PURE__*/new WeakMap();
var _readStorageFor = /*#__PURE__*/new WeakSet();
var _dirtyStorageFor = /*#__PURE__*/new WeakSet();
class TrackedArray {
  /**
   * Creates an array from an iterable object.
   * @param iterable An iterable object to convert to an array.
   */

  /**
   * Creates an array from an iterable object.
   * @param iterable An iterable object to convert to an array.
   * @param mapfn A mapping function to call on every element of the array.
   * @param thisArg Value of 'this' used to invoke the mapfn.
   */

  static from(iterable, mapfn, thisArg) {
    return mapfn ? new TrackedArray(Array.from(iterable, mapfn, thisArg)) : new TrackedArray(Array.from(iterable));
  }
  static of(...arr) {
    return new TrackedArray(arr);
  }
  constructor(arr = []) {
    _classPrivateMethodInitSpec(this, _dirtyStorageFor);
    _classPrivateMethodInitSpec(this, _readStorageFor);
    _classPrivateFieldInitSpec(this, _collection, {
      writable: true,
      value: createStorage(null, () => false)
    });
    _classPrivateFieldInitSpec(this, _storages, {
      writable: true,
      value: new Map()
    });
    let clone = arr.slice();
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let self = this;
    let boundFns = new Map();
    return new Proxy(clone, {
      get(target, prop /*, _receiver */) {
        let index = convertToInt(prop);
        if (index !== null) {
          _classPrivateMethodGet(self, _readStorageFor, _readStorageFor2).call(self, index);
          getValue(_classPrivateFieldGet(self, _collection));
          return target[index];
        } else if (prop === 'length') {
          getValue(_classPrivateFieldGet(self, _collection));
        } else if (ARRAY_GETTER_METHODS.has(prop)) {
          let fn = boundFns.get(prop);
          if (fn === undefined) {
            fn = (...args) => {
              getValue(_classPrivateFieldGet(self, _collection));
              return target[prop](...args);
            };
            boundFns.set(prop, fn);
          }
          return fn;
        }
        return target[prop];
      },
      set(target, prop, value /*, _receiver */) {
        target[prop] = value;
        let index = convertToInt(prop);
        if (index !== null) {
          _classPrivateMethodGet(self, _dirtyStorageFor, _dirtyStorageFor2).call(self, index);
          setValue(_classPrivateFieldGet(self, _collection), null);
        } else if (prop === 'length') {
          setValue(_classPrivateFieldGet(self, _collection), null);
        }
        return true;
      },
      getPrototypeOf() {
        return TrackedArray.prototype;
      }
    });
  }
}

// This rule is correctly in the general case, but it doesn't understand
// declaration merging, which is how we're using the interface here. This
// declaration says that `TrackedArray` acts just like `Array<T>`, but also has
// the properties declared via the `class` declaration above -- but without the
// cost of a subclass, which is much slower that the proxied array behavior.
// That is: a `TrackedArray` *is* an `Array`, just with a proxy in front of
// accessors and setters, rather than a subclass of an `Array` which would be
// de-optimized by the browsers.
//
// eslint-disable-next-line @typescript-eslint/no-empty-interface
function _readStorageFor2(index) {
  const storages = _classPrivateFieldGet(this, _storages);
  let storage = storages.get(index);
  if (storage === undefined) {
    storage = createStorage(null, () => false);
    storages.set(index, storage);
  }
  getValue(storage);
}
function _dirtyStorageFor2(index) {
  const storage = _classPrivateFieldGet(this, _storages).get(index);
  if (storage) {
    setValue(storage, null);
  }
}

// Ensure instanceof works correctly
Object.setPrototypeOf(TrackedArray.prototype, Array.prototype);

export { TrackedArray as default };
//# sourceMappingURL=array.js.map
