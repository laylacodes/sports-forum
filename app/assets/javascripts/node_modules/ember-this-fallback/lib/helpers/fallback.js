"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ambiguousStatementFallbackWarning = exports.ambiguousAttrFallbackWarning = exports.maybeAddDeprecationsHelper = exports.ambiguousStatementFallback = exports.helperOrExpressionFallback = exports.wrapWithTryLookup = exports.buildtimeExpressionFallback = exports.mustacheNeedsFallback = exports.needsFallback = void 0;
const syntax_1 = require("@glimmer/syntax");
const lodash_1 = require("lodash");
const scope_stack_1 = require("./scope-stack");
const string_1 = require("./string");
const FALLBACK_DETAILS_MESSAGE = 'See https://github.com/tildeio/ember-this-fallback#embroider-compatibility for more details.';
function needsFallback(expr, scope) {
    return expr.type === 'PathExpression' && (0, scope_stack_1.headNotInScope)(expr.head, scope);
}
exports.needsFallback = needsFallback;
function mustacheNeedsFallback(node, scope) {
    return (node.params.length === 0 &&
        node.hash.pairs.length === 0 &&
        needsFallback(node.path, scope));
}
exports.mustacheNeedsFallback = mustacheNeedsFallback;
/**
 * Prefixes the `head` of the given `PathExpression` with `this`, making it a
 * `ThisHead`.
 *
 * For example:
 *
 * ```hbs
 * {{! before }}
 * {{global-helper property}}
 *
 * {{! after }}
 * {{global-helper this.property}}
 * ```
 *
 * or
 *
 * ```hbs
 * {{! before }}
 * {{property.value}}
 *
 * {{! after }}
 * {{this.property.value}}
 * ```
 */
function buildtimeExpressionFallback(expr) {
    const thisPath = `this.${stringifyPath(expr)}`;
    return syntax_1.builders.path(thisPath, expr.loc);
}
exports.buildtimeExpressionFallback = buildtimeExpressionFallback;
function runtimeExpressionFallback(expr, deprecation, binding) {
    const thisFallbackHelper = bindAddonHelper('this-fallback-helper', binding);
    return syntax_1.builders.sexpr(thisFallbackHelper, [
        syntax_1.builders.path('this'),
        syntax_1.builders.string(stringifyPath(expr.path)),
        deprecation ? syntax_1.builders.string(JSON.stringify(deprecation)) : syntax_1.builders.boolean(false),
    ]);
}
/**
 * Wraps a node with a `{{let}}` block that invokes the `tryLookupHelper` helper
 * to lookup the given ambiguous path heads as helpers at runtime. The results
 * of each lookup will be stored on a hash and available to the block with a
 * block param of the given name.
 *
 * This logic is contained within a `SubExpression` that can be used to replace
 * the ambiguous expression in the parent as shown below:
 *
 * ```hbs
 * {{! example }}
 * {{#let (hash property=(tryLookupHelper 'property')) as |maybeHelpers|}}
 *   {{! ... given node here ... }}
 * {{/let}}
 * ```
 */
function wrapWithTryLookup(node, headsToLookup, blockParam, binding) {
    const tryLookupHelper = bindAddonHelper('try-lookup-helper', binding);
    const lookupsHash = syntax_1.builders.sexpr(syntax_1.builders.path('hash'), undefined, syntax_1.builders.hash([...headsToLookup].map((headName) => syntax_1.builders.pair(headName, syntax_1.builders.sexpr(tryLookupHelper, [syntax_1.builders.string(headName)])))));
    return syntax_1.builders.block(syntax_1.builders.path('let'), [lookupsHash], null, syntax_1.builders.blockItself([node], [blockParam]), null, node.loc);
}
exports.wrapWithTryLookup = wrapWithTryLookup;
/**
 * Provides a sub-expression that is useful within a node in a `{{let}}` block
 * that invokes the `tryLookupHelper`. If the property exists on the block param
 * with the given name, it will be invoked as a helper. If not, will use
 * `expressionFallback`.
 *
 * ```hbs
 * (if maybeHelpers.property (maybeHelpers.property) (thisFallbackHelper this 'property' 'Deprecation message'))
 * ```
 */
function helperOrExpressionFallback(blockParamName, expr, deprecation, binding) {
    const headName = expr.path.head.name;
    const maybeHelper = `${blockParamName}.${headName}`;
    return syntax_1.builders.sexpr(syntax_1.builders.path('if'), [
        syntax_1.builders.path(maybeHelper),
        syntax_1.builders.sexpr(syntax_1.builders.path(maybeHelper)),
        runtimeExpressionFallback(expr, deprecation, binding),
    ]);
}
exports.helperOrExpressionFallback = helperOrExpressionFallback;
/**
 * Wraps an ambiguous expression with the `isComponent` helper to determine if
 * it is a component at runtime. If so, invokes it as a component. If not, wraps
 * the invocation with the `tryLookupHelper` helper to determine if it is a
 * helper at runtime and fallback to the `this` property if not.
 *
 * ```hbs
 * {{! before }}
 * {{property}}
 *
 * {{! after }}
 * {{#if (isComponent "property")}}
 *   <Property />
 * {{else}}
 *   {{#let (hash property=(tryLookupHelper "property")) as |maybeHelpers|}}
 *     {{(if maybeHelpers.property (maybeHelpers.property) this.property)}}
 *   {{/let}}
 * {{/if}}
 * ```
 */
function ambiguousStatementFallback(expr, path, scope, deprecation, binding) {
    const headName = expr.path.head.name;
    const isComponent = bindAddonHelper('is-component', binding);
    const blockParamName = (0, scope_stack_1.unusedNameLike)('maybeHelpers', scope);
    const maybeHelperFallback = syntax_1.builders.mustache(helperOrExpressionFallback(blockParamName, expr, deprecation, binding));
    const tryLookup = wrapWithTryLookup(maybeHelperFallback, new Set([headName]), blockParamName, binding);
    return syntax_1.builders.block(syntax_1.builders.path('if'), [syntax_1.builders.sexpr(isComponent, [syntax_1.builders.string(headName)])], null, syntax_1.builders.blockItself([syntax_1.builders.element({ name: (0, string_1.classify)(headName), selfClosing: true })]), syntax_1.builders.blockItself([tryLookup]), path.node.loc);
}
exports.ambiguousStatementFallback = ambiguousStatementFallback;
function maybeAddDeprecationsHelper(template, deprecations, binding) {
    if (deprecations.length > 0) {
        const deprecationsHelper = bindAddonHelper('deprecations-helper', binding);
        template.body.push(syntax_1.builders.mustache(syntax_1.builders.path(deprecationsHelper), [
            syntax_1.builders.string(JSON.stringify(deprecations)),
        ]));
    }
}
exports.maybeAddDeprecationsHelper = maybeAddDeprecationsHelper;
function ambiguousAttrFallbackWarning(headName) {
    const original = `{{${headName}}}`;
    return [
        `Found ambiguous mustache statement as attribute node value \`${original}\`.`,
        `Falling back to runtime dynamic resolution. You can avoid this fallback by:`,
        `- ${explicitHelperSuggestion(headName)}`,
        `- ${thisPropertySuggestion(headName)}`,
        FALLBACK_DETAILS_MESSAGE,
    ];
}
exports.ambiguousAttrFallbackWarning = ambiguousAttrFallbackWarning;
function ambiguousStatementFallbackWarning(headName) {
    return [
        `Found ambiguous mustache statement: \`{{${headName}}}\`.`,
        `Falling back to runtime dynamic resolution. You can avoid this fallback by:`,
        `- ${explicitHelperSuggestion(headName)}`,
        `- ${explicitComponentSuggestion(headName)}`,
        `- ${thisPropertySuggestion(headName)}`,
        FALLBACK_DETAILS_MESSAGE,
    ];
}
exports.ambiguousStatementFallbackWarning = ambiguousStatementFallbackWarning;
function explicitComponentSuggestion(name) {
    const invocation = `<${(0, string_1.classify)(name)} />`;
    return `explicitly invoking a known component with angle-brackets: \`${invocation}\``;
}
function explicitHelperSuggestion(name) {
    return `explicitly invoking a known helper with parens: \`{{(${name})}}\``;
}
function thisPropertySuggestion(name) {
    return `prefacing a known property on \`this\` with \`this\`: \`{{this.${name}}}\``;
}
function bindAddonHelper(helperName, { bindImport, bindingTarget }, exportedName = 'default') {
    return bindImport(`ember-this-fallback/${helperName}`, exportedName, bindingTarget, { nameHint: (0, lodash_1.camelCase)(helperName) });
}
function stringifyPath(expr) {
    return [expr.head.name, ...expr.tail].join('.');
}
