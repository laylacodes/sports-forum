"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const syntax_1 = require("@glimmer/syntax");
const ast_1 = require("./helpers/ast");
const deprecations_1 = require("./helpers/deprecations");
const fallback_1 = require("./helpers/fallback");
const logger_1 = require("./helpers/logger");
const scope_stack_1 = __importStar(require("./helpers/scope-stack"));
const string_1 = require("./helpers/string");
const assert_1 = __importDefault(require("./types/assert"));
class ThisFallbackPlugin {
    constructor(name, env, logger) {
        this.name = name;
        this.env = env;
        this.logger = logger;
        this.deprecations = [];
        this.bindImport = (...args) => this.env.meta.jsutils.bindImport(...args);
        this.visitor = {
            Template: this.handleTemplate(),
            Block: this.handleBlock(),
            ElementNode: {
                keys: { children: this.handleBlock() },
                ...this.handleAttrNodes(),
            },
            MustacheStatement: {
                ...this.handleCall(),
                ...this.handleMustache(),
            },
            BlockStatement: this.handleCall(),
            ElementModifierStatement: this.handleCall(),
            SubExpression: this.handleCall(),
        };
        this.scopeStack = new scope_stack_1.default();
    }
    handleBlock() {
        return {
            enter: (node) => {
                this.scopeStack.push(node.blockParams);
            },
            exit: () => {
                this.scopeStack.pop();
            },
        };
    }
    handleAttrNodes() {
        return {
            enter: (elementNode, elementPath) => {
                const ambiguousHeads = new Map();
                const blockParamName = (0, scope_stack_1.unusedNameLike)('maybeHelpers', this.scopeStack);
                for (const attrNode of elementNode.attributes) {
                    const value = attrNode.value;
                    if ((0, ast_1.isNode)(value, 'MustacheStatement') &&
                        (0, fallback_1.mustacheNeedsFallback)(value, this.scopeStack)) {
                        // redundant but necessary because of overly strict types in @glimmer/syntax
                        (0, ast_1.assertIsNode)(attrNode.value, 'MustacheStatement');
                        if (attrNode.name.startsWith('@')) {
                            this.deprecateFallback(value.path.head.name);
                            attrNode.value.path = (0, fallback_1.buildtimeExpressionFallback)(value.path);
                        }
                        else {
                            ambiguousHeads.set(value.path.head.name, value.loc);
                            attrNode.value.path = (0, fallback_1.helperOrExpressionFallback)(blockParamName, value, this.makeFallbackDeprecation(value.path.head.name), { bindImport: this.bindImport, bindingTarget: elementPath });
                        }
                    }
                    else if ((0, ast_1.isNode)(value, 'ConcatStatement')) {
                        for (const part of value.parts) {
                            const p = part;
                            if ((0, ast_1.isNode)(p, 'MustacheStatement') &&
                                (0, fallback_1.mustacheNeedsFallback)(p, this.scopeStack)) {
                                // redundant but necessary because of overly strict types in @glimmer/syntax
                                (0, ast_1.assertIsNode)(part, 'MustacheStatement');
                                ambiguousHeads.set(p.path.head.name, p.loc);
                                part.path = (0, fallback_1.helperOrExpressionFallback)(blockParamName, p, this.makeFallbackDeprecation(p.path.head.name), { bindImport: this.bindImport, bindingTarget: elementPath });
                            }
                        }
                    }
                }
                if (ambiguousHeads.size > 0) {
                    // Only logs the first one to avoid mega-log-spew.
                    const firstIssue = [...ambiguousHeads.entries()][0];
                    this.logger.warn({
                        message: (0, fallback_1.ambiguousAttrFallbackWarning)(firstIssue[0]),
                        loc: firstIssue[1],
                    });
                    return (0, fallback_1.wrapWithTryLookup)(elementPath.node, new Set(ambiguousHeads.keys()), blockParamName, { bindImport: this.bindImport, bindingTarget: elementPath });
                }
                else {
                    return elementNode;
                }
            },
        };
    }
    handleCall() {
        return {
            keys: {
                params: (node) => {
                    const { scopeStack } = this;
                    node.params = node.params.map((expr) => {
                        if ((0, fallback_1.needsFallback)(expr, scopeStack)) {
                            this.deprecateFallback(expr.head.name);
                            return (0, fallback_1.buildtimeExpressionFallback)(expr);
                        }
                        else {
                            return expr;
                        }
                    });
                },
                hash: (node) => {
                    const { scopeStack } = this;
                    node.hash.pairs = node.hash.pairs.map((pair) => {
                        const { key, value: expr, loc } = pair;
                        if ((0, fallback_1.needsFallback)(expr, scopeStack)) {
                            this.deprecateFallback(expr.head.name);
                            return syntax_1.builders.pair(key, (0, fallback_1.buildtimeExpressionFallback)(expr), loc);
                        }
                        else {
                            return pair;
                        }
                    });
                },
            },
        };
    }
    handleMustache() {
        return {
            enter: (node, path) => {
                // Alias node to n so that the type of `node` doesn't get narrowed,
                // which prevents mutation
                const n = node;
                if ((0, fallback_1.mustacheNeedsFallback)(n, this.scopeStack)) {
                    (0, assert_1.default)('unexpected AmbiguousMustacheExpression in attribute value', path.parentNode?.type !== 'AttrNode');
                    if (n.path.tail.length > 0) {
                        this.deprecateFallback(n.path.head.name);
                        node.path = (0, fallback_1.buildtimeExpressionFallback)(n.path);
                        return node;
                    }
                    else {
                        this.logger.warn({
                            message: (0, fallback_1.ambiguousStatementFallbackWarning)(n.path.head.name),
                            loc: node.loc,
                        });
                        return (0, fallback_1.ambiguousStatementFallback)(n, path, this.scopeStack, this.makeFallbackDeprecation(n.path.head.name), { bindImport: this.bindImport, bindingTarget: path });
                    }
                }
                return node;
            },
        };
    }
    handleTemplate() {
        return {
            enter: (node) => {
                this.logger.debug("before: '%s'", (0, string_1.squish)((0, syntax_1.print)(node)));
            },
            exit: (node, path) => {
                this.logger.debug("after_: '%s'", (0, string_1.squish)((0, syntax_1.print)(node)));
                if (this.scopeStack.size !== 1) {
                    throw new Error(`unbalanced ScopeStack push and pop, ScopeStack size is ${this.scopeStack.size}`);
                }
                (0, fallback_1.maybeAddDeprecationsHelper)(node, this.deprecations, {
                    bindImport: this.bindImport,
                    bindingTarget: path,
                });
            },
        };
    }
    deprecate(message, test, options) {
        if (!test) {
            this.deprecations.push([message, false, options]);
        }
    }
    deprecateFallback(headName) {
        this.deprecate(...this.makeFallbackDeprecation(headName));
    }
    makeFallbackDeprecation(headName) {
        return [
            // Matches message from https://github.com/glimmerjs/glimmer-vm/pull/1259
            `The \`${headName}\` property path was used in the \`${this.env.moduleName}\` template without using \`this\`. This fallback behavior has been deprecated, all properties must be looked up on \`this\` when used in the template: {{this.${headName}}}`,
            false,
            (0, deprecations_1.deprecationOptionsFor)('this-property-fallback'),
        ];
    }
}
class NoopPlugin {
    constructor(name) {
        this.name = name;
        this.visitor = {};
    }
}
function buildThisFallbackPlugin({ enableLogging, }) {
    return (env) => {
        const name = 'ember-this-fallback';
        const logger = (0, logger_1.noopLogger)();
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (env.meta.jsutils) {
            return new ThisFallbackPlugin(name, env, logger);
        }
        else {
            const errorMessage = [
                'The this-fallback-plugin relies on the JSUtils from babel-plugin-ember-template-compilation, but none were found.',
                'To resolve this issue, please ensure you are running the latest version of ember-cli-htmlbars.',
            ];
            if (enableLogging) {
                logger.error([
                    'The this-fallback-plugin relies on the JSUtils from babel-plugin-ember-template-compilation, but none were found.',
                    'To resolve this issue, please ensure you are running the latest version of ember-cli-htmlbars.',
                ]);
                return new NoopPlugin(name);
            }
            else {
                throw new Error(errorMessage.join(' '));
            }
        }
    };
}
module.exports = buildThisFallbackPlugin;
