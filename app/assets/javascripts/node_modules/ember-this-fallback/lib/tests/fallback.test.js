"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const syntax_1 = require("@glimmer/syntax");
const globals_1 = require("@jest/globals");
const fallback_1 = require("../helpers/fallback");
const scope_stack_1 = __importDefault(require("../helpers/scope-stack"));
const string_1 = require("../helpers/string");
const IN_SCOPE = 'inScope';
const NOT_IN_SCOPE = 'notInScope';
const noParams = undefined;
const noHash = undefined;
const withHash = syntax_1.builders.hash([syntax_1.builders.pair('arg', syntax_1.builders.boolean(true))]);
const withParams = [syntax_1.builders.string('positional-param')];
const mockBindImport = (_moduleSpecifier, _exportedName, _target, opts) => opts?.nameHint ?? 'unknown';
(0, globals_1.describe)('fallback helpers', () => {
    let scopeStack;
    (0, globals_1.beforeEach)(() => {
        scopeStack = new scope_stack_1.default();
        scopeStack.push([IN_SCOPE]);
    });
    (0, globals_1.describe)('PathExpression', () => {
        const fallbackCases = [
            syntax_1.builders.path(NOT_IN_SCOPE),
            syntax_1.builders.path(`${NOT_IN_SCOPE}.tail`),
        ];
        const noFallbackCases = [
            syntax_1.builders.path(IN_SCOPE),
            syntax_1.builders.path(`${IN_SCOPE}.tail`),
            syntax_1.builders.path('array'),
            syntax_1.builders.string('a-string'),
            syntax_1.builders.boolean(true),
            syntax_1.builders.sexpr(IN_SCOPE),
            syntax_1.builders.sexpr(NOT_IN_SCOPE),
            syntax_1.builders.number(1),
            syntax_1.builders.undefined(),
            syntax_1.builders.null(),
        ];
        (0, globals_1.describe)('needsFallback', () => {
            for (const testCase of fallbackCases) {
                (0, globals_1.describe)((0, syntax_1.print)(testCase), () => {
                    (0, globals_1.test)('returns true', () => {
                        (0, globals_1.expect)((0, fallback_1.needsFallback)(testCase, scopeStack)).toBe(true);
                    });
                });
            }
            for (const testCase of noFallbackCases) {
                (0, globals_1.describe)((0, syntax_1.print)(testCase), () => {
                    (0, globals_1.test)('returns false', () => {
                        (0, globals_1.expect)((0, fallback_1.needsFallback)(testCase, scopeStack)).toBe(false);
                    });
                });
            }
        });
        (0, globals_1.describe)('expressionFallback', () => {
            for (const testCase of fallbackCases) {
                (0, globals_1.describe)((0, syntax_1.print)(testCase), () => {
                    (0, globals_1.test)('has this-fallback', () => {
                        (0, globals_1.expect)((0, syntax_1.print)((0, fallback_1.buildtimeExpressionFallback)(testCase))).toEqual(`this.${(0, syntax_1.print)(testCase)}`);
                    });
                });
            }
        });
    });
    (0, globals_1.describe)('MustacheStatement', () => {
        const needsExpressionFallback = syntax_1.builders.mustache(syntax_1.builders.path(`${NOT_IN_SCOPE}.tail`), noParams, noHash);
        const needsAmbiguousFallback = syntax_1.builders.mustache(syntax_1.builders.path(NOT_IN_SCOPE), noParams, noHash);
        const fallbackCases = [needsExpressionFallback, needsAmbiguousFallback];
        const noFallbackCases = [
            syntax_1.builders.mustache(syntax_1.builders.path(NOT_IN_SCOPE), withParams, noHash),
            syntax_1.builders.mustache(syntax_1.builders.path(NOT_IN_SCOPE), noParams, withHash),
            syntax_1.builders.mustache(syntax_1.builders.path(NOT_IN_SCOPE), withParams, withHash),
            syntax_1.builders.mustache(syntax_1.builders.path(IN_SCOPE), noParams, noHash),
            syntax_1.builders.mustache(syntax_1.builders.path(IN_SCOPE), withParams, noHash),
            syntax_1.builders.mustache(syntax_1.builders.path(IN_SCOPE), noParams, withHash),
            syntax_1.builders.mustache(syntax_1.builders.path(IN_SCOPE), withParams, withHash),
            syntax_1.builders.mustache(syntax_1.builders.path(`${NOT_IN_SCOPE}.tail`), withParams, noHash),
            syntax_1.builders.mustache(syntax_1.builders.path(`${NOT_IN_SCOPE}.tail`), noParams, withHash),
            syntax_1.builders.mustache(syntax_1.builders.path(`${NOT_IN_SCOPE}.tail`), withParams, withHash),
            syntax_1.builders.mustache(syntax_1.builders.path(`${IN_SCOPE}.tail`), noParams, noHash),
            syntax_1.builders.mustache(syntax_1.builders.path(`${IN_SCOPE}.tail`), withParams, noHash),
            syntax_1.builders.mustache(syntax_1.builders.path(`${IN_SCOPE}.tail`), noParams, withHash),
            syntax_1.builders.mustache(syntax_1.builders.path(`${IN_SCOPE}.tail`), withParams, withHash),
            syntax_1.builders.mustache(syntax_1.builders.path('array')),
            syntax_1.builders.mustache(syntax_1.builders.string('a-string')),
            syntax_1.builders.mustache(syntax_1.builders.boolean(true)),
            syntax_1.builders.mustache(syntax_1.builders.sexpr(IN_SCOPE)),
            syntax_1.builders.mustache(syntax_1.builders.sexpr(NOT_IN_SCOPE)),
            syntax_1.builders.mustache(syntax_1.builders.number(1)),
            syntax_1.builders.mustache(syntax_1.builders.undefined()),
            syntax_1.builders.mustache(syntax_1.builders.null()),
        ];
        (0, globals_1.describe)('mustacheNeedsFallback', () => {
            for (const testCase of fallbackCases) {
                (0, globals_1.describe)((0, syntax_1.print)(testCase), () => {
                    (0, globals_1.test)('returns true', () => {
                        (0, globals_1.expect)((0, fallback_1.mustacheNeedsFallback)(testCase, scopeStack)).toBe(true);
                    });
                });
            }
            for (const testCase of noFallbackCases) {
                (0, globals_1.describe)((0, syntax_1.print)(testCase), () => {
                    (0, globals_1.test)('returns false', () => {
                        (0, globals_1.expect)((0, fallback_1.mustacheNeedsFallback)(testCase, scopeStack)).toBe(false);
                    });
                });
            }
        });
        (0, globals_1.describe)('expressionFallback', () => {
            (0, globals_1.describe)((0, syntax_1.print)(needsExpressionFallback), () => {
                (0, globals_1.test)('has this-fallback', () => {
                    (0, globals_1.expect)((0, syntax_1.print)((0, fallback_1.buildtimeExpressionFallback)(needsExpressionFallback.path))).toEqual(`this.${NOT_IN_SCOPE}.tail`);
                });
            });
        });
        (0, globals_1.describe)('helperOrExpressionFallback', () => {
            (0, globals_1.describe)((0, syntax_1.print)(needsAmbiguousFallback), () => {
                (0, globals_1.test)('has this-fallback', () => {
                    const path = new syntax_1.WalkerPath(needsAmbiguousFallback);
                    (0, globals_1.expect)((0, syntax_1.print)((0, fallback_1.helperOrExpressionFallback)('maybeHelpers', needsAmbiguousFallback, false, { bindImport: mockBindImport, bindingTarget: path }))).toEqual(`(if maybeHelpers.${NOT_IN_SCOPE} (maybeHelpers.${NOT_IN_SCOPE}) (thisFallbackHelper this "${NOT_IN_SCOPE}" false))`);
                });
            });
        });
        (0, globals_1.describe)('wrapWithTryLookup', () => {
            (0, globals_1.describe)((0, syntax_1.print)(needsAmbiguousFallback), () => {
                (0, globals_1.test)('has this-fallback', () => {
                    const path = new syntax_1.WalkerPath(needsAmbiguousFallback);
                    (0, globals_1.expect)((0, syntax_1.print)((0, fallback_1.wrapWithTryLookup)(needsAmbiguousFallback, new Set([NOT_IN_SCOPE]), 'maybeHelpers', { bindImport: mockBindImport, bindingTarget: path }))).toEqual(`{{#let (hash ${NOT_IN_SCOPE}=(tryLookupHelper "${NOT_IN_SCOPE}")) as |maybeHelpers|}}{{${NOT_IN_SCOPE}}}{{/let}}`);
                });
            });
        });
        (0, globals_1.describe)('ambiguousStatementFallback', () => {
            (0, globals_1.describe)((0, syntax_1.print)(needsAmbiguousFallback), () => {
                (0, globals_1.test)('has this-fallback', () => {
                    const path = new syntax_1.WalkerPath(needsAmbiguousFallback);
                    (0, globals_1.expect)((0, syntax_1.print)((0, fallback_1.ambiguousStatementFallback)(needsAmbiguousFallback, path, scopeStack, false, { bindImport: mockBindImport, bindingTarget: path }))).toEqual(`{{#if (isComponent "${NOT_IN_SCOPE}")}}<${(0, string_1.classify)(NOT_IN_SCOPE)} />{{else}}{{#let (hash ${NOT_IN_SCOPE}=(tryLookupHelper "${NOT_IN_SCOPE}")) as |maybeHelpers|}}{{(if maybeHelpers.${NOT_IN_SCOPE} (maybeHelpers.${NOT_IN_SCOPE}) (thisFallbackHelper this "${NOT_IN_SCOPE}" false))}}{{/let}}{{/if}}`);
                });
            });
        });
    });
});
