"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _EmbroiderPlugin_instances, _EmbroiderPlugin_resolver, _EmbroiderPlugin_babelLoaderPrefix, _EmbroiderPlugin_appRoot, _EmbroiderPlugin_addLoaderAlias;
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbroiderPlugin = void 0;
const path_1 = require("path");
const core_1 = require("@embroider/core");
const assert_never_1 = __importDefault(require("assert-never"));
const escape_string_regexp_1 = __importDefault(require("escape-string-regexp"));
const virtualLoaderName = '@embroider/webpack/src/virtual-loader';
const virtualLoaderPath = (0, path_1.resolve)(__dirname, './virtual-loader.js');
const virtualRequestPattern = new RegExp(`${(0, escape_string_regexp_1.default)(virtualLoaderPath)}\\?(?<query>.+)!`);
class EmbroiderPlugin {
    constructor(opts, babelLoaderPrefix) {
        _EmbroiderPlugin_instances.add(this);
        _EmbroiderPlugin_resolver.set(this, void 0);
        _EmbroiderPlugin_babelLoaderPrefix.set(this, void 0);
        _EmbroiderPlugin_appRoot.set(this, void 0);
        __classPrivateFieldSet(this, _EmbroiderPlugin_resolver, new core_1.Resolver(opts), "f");
        __classPrivateFieldSet(this, _EmbroiderPlugin_babelLoaderPrefix, babelLoaderPrefix, "f");
        __classPrivateFieldSet(this, _EmbroiderPlugin_appRoot, opts.appRoot, "f");
    }
    apply(compiler) {
        __classPrivateFieldGet(this, _EmbroiderPlugin_instances, "m", _EmbroiderPlugin_addLoaderAlias).call(this, compiler, virtualLoaderName, virtualLoaderPath);
        compiler.hooks.normalModuleFactory.tap('@embroider/webpack', nmf => {
            let defaultResolve = getDefaultResolveHook(nmf.hooks.resolve.taps);
            let adaptedResolve = getAdaptedResolve(defaultResolve);
            nmf.hooks.resolve.tapAsync({ name: '@embroider/webpack', stage: 50 }, (state, callback) => {
                let request = WebpackModuleRequest.from(state, __classPrivateFieldGet(this, _EmbroiderPlugin_babelLoaderPrefix, "f"), __classPrivateFieldGet(this, _EmbroiderPlugin_appRoot, "f"));
                if (!request) {
                    defaultResolve(state, callback);
                    return;
                }
                __classPrivateFieldGet(this, _EmbroiderPlugin_resolver, "f").resolve(request, adaptedResolve).then(resolution => {
                    switch (resolution.type) {
                        case 'not_found':
                            callback(resolution.err);
                            break;
                        case 'found':
                            callback(null, resolution.result);
                            break;
                        default:
                            throw (0, assert_never_1.default)(resolution);
                    }
                }, err => callback(err));
            });
        });
    }
}
exports.EmbroiderPlugin = EmbroiderPlugin;
_EmbroiderPlugin_resolver = new WeakMap(), _EmbroiderPlugin_babelLoaderPrefix = new WeakMap(), _EmbroiderPlugin_appRoot = new WeakMap(), _EmbroiderPlugin_instances = new WeakSet(), _EmbroiderPlugin_addLoaderAlias = function _EmbroiderPlugin_addLoaderAlias(compiler, name, alias) {
    let { resolveLoader } = compiler.options;
    if (Array.isArray(resolveLoader.alias)) {
        resolveLoader.alias.push({ name, alias });
    }
    else if (resolveLoader.alias) {
        resolveLoader.alias[name] = alias;
    }
    else {
        resolveLoader.alias = {
            [name]: alias,
        };
    }
};
// Despite being absolutely riddled with way-too-powerful tap points,
// webpack still doesn't succeed in making it possible to provide a
// fallback to the default resolve hook in the NormalModuleFactory. So
// instead we will find the default behavior and call it from our own tap,
// giving us a chance to handle its failures.
function getDefaultResolveHook(taps) {
    let { fn } = taps.find(t => t.name === 'NormalModuleFactory');
    return fn;
}
// This converts the raw function we got out of webpack into the right interface
// for use by @embroider/core's resolver.
function getAdaptedResolve(defaultResolve) {
    return function (request) {
        return new Promise(resolve => {
            defaultResolve(request.state, (err, value) => {
                if (err) {
                    // unfortunately webpack doesn't let us distinguish between Not Found
                    // and other unexpected exceptions here.
                    resolve({ type: 'not_found', err });
                }
                else {
                    resolve({ type: 'found', result: value });
                }
            });
        });
    };
}
class WebpackModuleRequest {
    static from(state, babelLoaderPrefix, appRoot) {
        var _a, _b, _c;
        // when the files emitted from our virtual-loader try to import things,
        // those requests show in webpack as having no issuer. But we can see here
        // which requests they are and adjust the issuer so they resolve things from
        // the correct logical place.
        if (!((_a = state.contextInfo) === null || _a === void 0 ? void 0 : _a.issuer) && Array.isArray(state.dependencies)) {
            for (let dep of state.dependencies) {
                let match = virtualRequestPattern.exec((_b = dep._parentModule) === null || _b === void 0 ? void 0 : _b.userRequest);
                if (match) {
                    state.contextInfo.issuer = new URLSearchParams(match.groups.query).get('f');
                    state.context = (0, path_1.dirname)(state.contextInfo.issuer);
                }
            }
        }
        if (typeof state.request === 'string' &&
            typeof state.context === 'string' &&
            typeof ((_c = state.contextInfo) === null || _c === void 0 ? void 0 : _c.issuer) === 'string' &&
            state.contextInfo.issuer !== '' &&
            !state.request.includes(virtualLoaderName) && // prevents recursion on requests we have already sent to our virtual loader
            !state.request.startsWith('!') // ignores internal webpack resolvers
        ) {
            return new WebpackModuleRequest(babelLoaderPrefix, appRoot, state);
        }
    }
    constructor(babelLoaderPrefix, appRoot, state, isVirtual = false) {
        this.babelLoaderPrefix = babelLoaderPrefix;
        this.appRoot = appRoot;
        this.state = state;
        this.isVirtual = isVirtual;
        // these get copied here because we mutate the underlying state as we
        // convert one request into the next, and it seems better for debuggability
        // if the fields on the previous request don't change when you make a new
        // one (although it is true that only the newest one has a a valid `state`
        // that can actually be handed back to webpack)
        this.specifier = state.request;
        this.fromFile = state.contextInfo.issuer;
        this.meta = state.contextInfo._embroiderMeta ? { ...state.contextInfo._embroiderMeta } : undefined;
    }
    alias(newSpecifier) {
        this.state.request = newSpecifier;
        return new WebpackModuleRequest(this.babelLoaderPrefix, this.appRoot, this.state);
    }
    rehome(newFromFile) {
        if (this.fromFile === newFromFile) {
            return this;
        }
        else {
            this.state.contextInfo.issuer = newFromFile;
            this.state.context = (0, path_1.dirname)(newFromFile);
            return new WebpackModuleRequest(this.babelLoaderPrefix, this.appRoot, this.state);
        }
    }
    virtualize(filename) {
        let params = new URLSearchParams();
        params.set('f', filename);
        params.set('a', this.appRoot);
        let next = this.alias(`${this.babelLoaderPrefix}${virtualLoaderName}?${params.toString()}!`);
        next.isVirtual = true;
        return next;
    }
    withMeta(meta) {
        this.state.contextInfo._embroiderMeta = meta;
        return new WebpackModuleRequest(this.babelLoaderPrefix, this.appRoot, this.state);
    }
}
//# sourceMappingURL=webpack-resolver-plugin.js.map