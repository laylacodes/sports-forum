"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeStyleLink = exports.normalizeScriptTag = exports.makeTag = void 0;
function makeTag(document, { from, tag, attributes } = {}) {
    if (!tag && from) {
        tag = from.tagName;
    }
    if (!tag) {
        throw new Error('Must supply one of `options.from` or `options.tag`');
    }
    let cloned = document.createElement(tag);
    let overrides = new Map(Object.entries(attributes !== null && attributes !== void 0 ? attributes : {}));
    if (from) {
        for (let { name, value: originalValue } of from.attributes) {
            let value = overrides.has(name) ? overrides.get(name) : originalValue;
            overrides.delete(name);
            if (value === null) {
                continue;
            }
            else {
                cloned.setAttribute(name, value);
            }
        }
    }
    for (let [name, value] of overrides) {
        if (value !== null) {
            cloned.setAttribute(name, value);
        }
    }
    return cloned;
}
exports.makeTag = makeTag;
function normalizeScriptTag(tag) {
    if (tag.getAttribute('type') === 'module') {
        // we always convert modules to scripts, dropping
        tag.removeAttribute('type');
    }
}
exports.normalizeScriptTag = normalizeScriptTag;
function normalizeStyleLink(tag) {
    let rel = tag.getAttribute('rel');
    if (rel === null) {
        tag.setAttribute('rel', 'stylesheet');
    }
    else if (!rel.includes('stylesheet')) {
        tag.setAttribute('rel', `${rel} stylesheet`);
    }
}
exports.normalizeStyleLink = normalizeStyleLink;
class Placeholder {
    // remove the target Element from the DOM, and track where it was so we can
    // update that location later.
    constructor(target) {
        this.target = target;
        if (!target.ownerDocument || !target.parentElement) {
            throw new Error('can only construct a placeholder for an element that is in DOM');
        }
        let start = target.ownerDocument.createTextNode('');
        target.parentElement.insertBefore(start, target);
        let endNode = target.ownerDocument.createTextNode('');
        target.replaceWith(endNode);
        // Type cast is justified because start always has a nextSibling (it's
        // "end") and because we know we already inserted the node.
        this.start = start;
        // Type cast is justified because we know we already inserted the node.
        this.end = endNode;
    }
    reset() {
        this.clear();
        this.insert(this.target);
    }
    clear() {
        while (this.start.nextSibling !== this.end) {
            this.start.parentElement.removeChild(this.start.nextSibling);
        }
    }
    insert(node) {
        this.end.parentElement.insertBefore(node, this.end);
    }
    appendToHead(node) {
        this.end.ownerDocument.head.appendChild(node);
    }
    isScript() {
        return this.target.tagName === 'SCRIPT';
    }
    insertURL(url) {
        if (url.endsWith('.js')) {
            return this.insertScriptTag(url);
        }
        if (url.endsWith('.css')) {
            return this.insertStyleLink(url);
        }
        throw new Error(`don't know how to insertURL ${url}`);
    }
    insertScriptTag(src) {
        let newTag = makeTag(this.end.ownerDocument, { from: this.target, attributes: { src } });
        normalizeScriptTag(newTag);
        this.insert(newTag);
        this.insertNewline();
        return newTag;
    }
    insertStyleLink(href) {
        let newTag;
        if (this.isScript()) {
            // Add dynamic styles from scripts to the bottom of the head, and not to where the script was,
            // to prevent FOUC when pre-rendering (FastBoot)
            newTag = makeTag(this.end.ownerDocument, {
                from: this.target,
                tag: 'link',
                attributes: { href, type: null, src: null },
            });
            normalizeStyleLink(newTag);
            this.appendToHead(newTag);
        }
        else {
            // Keep the new style in the same place as the original one
            newTag = makeTag(this.end.ownerDocument, { from: this.target, attributes: { href } });
            normalizeStyleLink(newTag);
            this.insert(newTag);
        }
        this.insertNewline(newTag);
    }
    insertNewline(node = this.end) {
        node.parentElement.insertBefore(node.ownerDocument.createTextNode('\n'), node);
    }
}
exports.default = Placeholder;
//# sourceMappingURL=html-placeholder.js.map