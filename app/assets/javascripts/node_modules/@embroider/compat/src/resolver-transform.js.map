{"version":3,"file":"resolver-transform.js","sourceRoot":"","sources":["resolver-transform.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ASTv1, ASTPlugin, ASTPluginBuilder, ASTPluginEnvironment, WalkerPath } from '@glimmer/syntax';\nimport type {\n  PreprocessedComponentRule,\n  ActivePackageRules,\n  ComponentRules,\n  PackageRules,\n  ModuleRules,\n} from './dependency-rules';\nimport { preprocessComponentRule, appTreeRulesDir } from './dependency-rules';\nimport { Memoize } from 'typescript-memoize';\nimport type { WithJSUtils } from 'babel-plugin-ember-template-compilation';\nimport assertNever from 'assert-never';\nimport { join, sep } from 'path';\nimport { readJSONSync } from 'fs-extra';\nimport { dasherize, snippetToDasherizedName } from './dasherize-component-name';\nimport type { ResolverOptions as CoreResolverOptions } from '@embroider/core';\nimport { Resolver, locateEmbroiderWorkingDir } from '@embroider/core';\nimport type CompatOptions from './options';\nimport type { AuditMessage, Loc } from './audit';\nimport { camelCase, mergeWith } from 'lodash';\n\ntype Env = WithJSUtils<ASTPluginEnvironment> & {\n  filename: string;\n  contents: string;\n  strictMode?: boolean;\n  locals?: string[];\n};\n\n// this is a subset of the full Options. We care about serializability, and we\n// only needs parts that are easily serializable, which is why we don't keep the\n// whole thing.\ntype UserConfig = Pick<\n  Required<CompatOptions>,\n  'staticHelpers' | 'staticModifiers' | 'staticComponents' | 'allowUnsafeDynamicComponents'\n>;\n\nexport interface CompatResolverOptions extends CoreResolverOptions {\n  activePackageRules: ActivePackageRules[];\n  options: UserConfig;\n}\n\nexport interface Options {\n  appRoot: string;\n}\n\nexport const builtInKeywords = [\n  '-get-dynamic-var',\n  '-in-element',\n  '-with-dynamic-vars',\n  'action',\n  'array',\n  'component',\n  'concat',\n  'debugger',\n  'each-in',\n  'each',\n  'fn',\n  'get',\n  'has-block-params',\n  'has-block',\n  'hasBlock',\n  'hasBlockParams',\n  'hash',\n  'helper',\n  'if',\n  'in-element',\n  'input',\n  'let',\n  'link-to',\n  'loc',\n  'log',\n  'modifier',\n  'mount',\n  'mut',\n  'on',\n  'outlet',\n  'partial',\n  'query-params',\n  'readonly',\n  'textarea',\n  'unbound',\n  'unique-id',\n  'unless',\n  'with',\n  'yield',\n];\n\ninterface ComponentResolution {\n  type: 'component';\n  specifier: string;\n  yieldsComponents: Required<ComponentRules>['yieldsSafeComponents'];\n  yieldsArguments: Required<ComponentRules>['yieldsArguments'];\n  argumentsAreComponents: string[];\n  nameHint: string;\n}\n\ntype HelperResolution = {\n  type: 'helper';\n  nameHint: string;\n  specifier: string;\n};\n\ntype ModifierResolution = {\n  type: 'modifier';\n  specifier: string;\n  nameHint: string;\n};\n\ntype ResolutionResult = ComponentResolution | HelperResolution | ModifierResolution;\n\ninterface ResolutionFail {\n  type: 'error';\n  message: string;\n  detail: string;\n  loc: Loc;\n}\n\ntype Resolution = ResolutionResult | ResolutionFail;\n\ntype ComponentLocator =\n  | {\n      type: 'literal';\n      path: string;\n    }\n  | {\n      type: 'path';\n      path: string;\n    }\n  | {\n      type: 'other';\n    };\n\nclass TemplateResolver implements ASTPlugin {\n  readonly name = 'embroider-build-time-resolver';\n\n  private auditHandler: undefined | ((msg: AuditMessage) => void);\n  private scopeStack = new ScopeStack();\n\n  private moduleResolver: Resolver;\n\n  constructor(private env: Env, private config: CompatResolverOptions) {\n    this.moduleResolver = new Resolver(config);\n    if ((globalThis as any).embroider_audit) {\n      this.auditHandler = (globalThis as any).embroider_audit;\n    }\n  }\n\n  private emit<Target extends WalkerPath<ASTv1.Node>>(\n    parentPath: Target,\n    resolution: Resolution | null,\n    setter: (target: Target['node'], newIdentifier: ASTv1.PathExpression) => void\n  ) {\n    switch (resolution?.type) {\n      case 'error':\n        this.reportError(resolution);\n        return;\n      case 'component':\n      case 'modifier':\n      case 'helper': {\n        let name = this.env.meta.jsutils.bindImport(resolution.specifier, 'default', parentPath, {\n          nameHint: resolution.nameHint,\n        });\n        setter(parentPath.node, this.env.syntax.builders.path(name));\n        return;\n      }\n      case undefined:\n        return;\n      default:\n        assertNever(resolution);\n    }\n  }\n\n  private reportError(dep: ResolutionFail) {\n    if (!this.auditHandler && !this.config.options.allowUnsafeDynamicComponents) {\n      let e: any = new Error(`${dep.message}: ${dep.detail} in ${this.humanReadableFile(this.env.filename)}`);\n      e.isTemplateResolverError = true;\n      e.loc = dep.loc;\n      e.moduleName = this.env.filename;\n      throw e;\n    }\n    if (this.auditHandler) {\n      this.auditHandler({\n        message: dep.message,\n        filename: this.env.filename,\n        detail: dep.detail,\n        loc: dep.loc,\n        source: this.env.contents,\n      });\n    }\n  }\n\n  private humanReadableFile(file: string) {\n    let { appRoot } = this.config;\n    if (!appRoot.endsWith(sep)) {\n      appRoot += sep;\n    }\n    if (file.startsWith(appRoot)) {\n      return file.slice(appRoot.length);\n    }\n    return file;\n  }\n\n  private handleComponentHelper(\n    param: ASTv1.Node,\n    impliedBecause?: { componentName: string; argumentName: string }\n  ): ComponentResolution | ResolutionFail | null {\n    let locator: ComponentLocator;\n    switch (param.type) {\n      case 'StringLiteral':\n        locator = { type: 'literal', path: param.value };\n        break;\n      case 'PathExpression':\n        locator = { type: 'path', path: param.original };\n        break;\n      case 'MustacheStatement':\n        if (param.hash.pairs.length === 0 && param.params.length === 0) {\n          return this.handleComponentHelper(param.path, impliedBecause);\n        } else if (param.path.type === 'PathExpression' && param.path.original === 'component') {\n          // safe because we will handle this inner `{{component ...}}` mustache on its own\n          return null;\n        } else {\n          locator = { type: 'other' };\n        }\n        break;\n      case 'TextNode':\n        locator = { type: 'literal', path: param.chars };\n        break;\n      case 'SubExpression':\n        if (param.path.type === 'PathExpression' && param.path.original === 'component') {\n          // safe because we will handle this inner `(component ...)` subexpression on its own\n          return null;\n        }\n        if (param.path.type === 'PathExpression' && param.path.original === 'ensure-safe-component') {\n          // safe because we trust ensure-safe-component\n          return null;\n        }\n        locator = { type: 'other' };\n        break;\n      default:\n        locator = { type: 'other' };\n    }\n\n    if (locator.type === 'path' && this.scopeStack.safeComponentInScope(locator.path)) {\n      return null;\n    }\n\n    return this.targetComponentHelper(locator, param.loc, impliedBecause);\n  }\n\n  private handleDynamicComponentArguments(\n    componentName: string,\n    argumentsAreComponents: string[],\n    attributes: WalkerPath<ASTv1.AttrNode | ASTv1.HashPair>[]\n  ) {\n    for (let name of argumentsAreComponents) {\n      let attr = attributes.find(attr => {\n        if (attr.node.type === 'AttrNode') {\n          return attr.node.name === '@' + name;\n        } else {\n          return attr.node.key === name;\n        }\n      });\n      if (attr) {\n        let resolution = this.handleComponentHelper(attr.node.value, {\n          componentName,\n          argumentName: name,\n        });\n        this.emit(attr, resolution, (node, newId) => {\n          if (node.type === 'AttrNode') {\n            node.value = this.env.syntax.builders.mustache(newId);\n          } else {\n            node.value = newId;\n          }\n        });\n      }\n    }\n  }\n\n  private get staticComponentsEnabled(): boolean {\n    return this.config.options.staticComponents || Boolean(this.auditHandler);\n  }\n\n  private get staticHelpersEnabled(): boolean {\n    return this.config.options.staticHelpers || Boolean(this.auditHandler);\n  }\n\n  private get staticModifiersEnabled(): boolean {\n    return this.config.options.staticModifiers || Boolean(this.auditHandler);\n  }\n\n  private isIgnoredComponent(dasherizedName: string) {\n    return this.rules.components.get(dasherizedName)?.safeToIgnore;\n  }\n\n  @Memoize()\n  private get rules() {\n    // rules that are keyed by the filename they're talking about\n    let files: Map<string, PreprocessedComponentRule> = new Map();\n\n    // rules that are keyed by our dasherized interpretation of the component's name\n    let components: Map<string, PreprocessedComponentRule> = new Map();\n\n    // we're not responsible for filtering out rules for inactive packages here,\n    // that is done before getting to us. So we should assume these are all in\n    // force.\n    for (let rule of this.config.activePackageRules) {\n      if (rule.components) {\n        for (let [snippet, rules] of Object.entries(rule.components)) {\n          let processedRules = preprocessComponentRule(rules);\n          let dasherizedName = this.standardDasherize(snippet, rule);\n          components.set(dasherizedName, processedRules);\n          if (rules.layout) {\n            for (let root of rule.roots) {\n              if (rules.layout.addonPath) {\n                files.set(join(root, rules.layout.addonPath), processedRules);\n              }\n              if (rules.layout.appPath) {\n                files.set(join(root, rules.layout.appPath), processedRules);\n              }\n            }\n          }\n        }\n      }\n      if (rule.appTemplates) {\n        for (let [path, templateRules] of Object.entries(rule.appTemplates)) {\n          let processedRules = preprocessComponentRule(templateRules);\n          for (let root of rule.roots) {\n            files.set(join(appTreeRulesDir(root, this.moduleResolver), path), processedRules);\n          }\n        }\n      }\n      if (rule.addonTemplates) {\n        for (let [path, templateRules] of Object.entries(rule.addonTemplates)) {\n          let processedRules = preprocessComponentRule(templateRules);\n          for (let root of rule.roots) {\n            files.set(join(root, path), processedRules);\n          }\n        }\n      }\n    }\n    return { files, components };\n  }\n\n  private findRules(absPath: string): PreprocessedComponentRule | undefined {\n    let fileRules = this.rules.files.get(absPath);\n    let componentRules: PreprocessedComponentRule | undefined;\n\n    let componentName = this.moduleResolver.reverseComponentLookup(absPath);\n    if (componentName) {\n      componentRules = this.rules.components.get(componentName);\n    }\n\n    if (fileRules && componentRules) {\n      return mergeWith(fileRules, componentRules, appendArrays);\n    }\n\n    return fileRules ?? componentRules;\n  }\n\n  private standardDasherize(snippet: string, rule: PackageRules | ModuleRules): string {\n    let name = snippetToDasherizedName(snippet);\n    if (name == null) {\n      throw new Error(`unable to parse component snippet \"${snippet}\" from rule ${JSON.stringify(rule, null, 2)}`);\n    }\n    return name;\n  }\n\n  private targetComponent(name: string): ComponentResolution | null {\n    if (!this.staticComponentsEnabled) {\n      return null;\n    }\n\n    if (builtInKeywords.includes(name)) {\n      return null;\n    }\n    if (this.isIgnoredComponent(name)) {\n      return null;\n    }\n\n    let componentRules = this.rules.components.get(name);\n    return {\n      type: 'component',\n      specifier: `#embroider_compat/components/${name}`,\n      yieldsComponents: componentRules ? componentRules.yieldsSafeComponents : [],\n      yieldsArguments: componentRules ? componentRules.yieldsArguments : [],\n      argumentsAreComponents: componentRules ? componentRules.argumentsAreComponents : [],\n      nameHint: this.nameHint(name),\n    };\n  }\n\n  private targetComponentHelper(\n    component: ComponentLocator,\n    loc: Loc,\n    impliedBecause?: { componentName: string; argumentName: string }\n  ): ComponentResolution | ResolutionFail | null {\n    if (!this.staticComponentsEnabled) {\n      return null;\n    }\n\n    let message;\n    if (impliedBecause) {\n      message = `argument \"${impliedBecause.argumentName}\" to component \"${impliedBecause.componentName}\" is treated as a component, but the value you're passing is dynamic`;\n    } else {\n      message = `Unsafe dynamic component`;\n    }\n\n    if (component.type === 'other') {\n      return {\n        type: 'error',\n        message,\n        detail: `cannot statically analyze this expression`,\n        loc,\n      };\n    }\n    if (component.type === 'path') {\n      let ownComponentRules = this.findRules(this.env.filename);\n      if (ownComponentRules && ownComponentRules.safeInteriorPaths.includes(component.path)) {\n        return null;\n      }\n      return {\n        type: 'error',\n        message,\n        detail: component.path,\n        loc,\n      };\n    }\n\n    return this.targetComponent(component.path);\n  }\n\n  private targetHelper(path: string): HelperResolution | null {\n    if (!this.staticHelpersEnabled) {\n      return null;\n    }\n\n    // people are not allowed to override the built-in helpers with their own\n    // globally-named helpers. It throws an error. So it's fine for us to\n    // prioritize the builtIns here without bothering to resolve a user helper\n    // of the same name.\n    if (builtInKeywords.includes(path)) {\n      return null;\n    }\n\n    return {\n      type: 'helper',\n      specifier: `#embroider_compat/helpers/${path}`,\n      nameHint: this.nameHint(path),\n    };\n  }\n\n  private targetHelperOrComponent(\n    path: string,\n    loc: Loc,\n    hasArgs: boolean\n  ): ComponentResolution | HelperResolution | null {\n    /*\n\n    In earlier embroider versions we would do a bunch of module resolution right\n    here inside the ast transform to try to resolve the ambiguity of this case\n    and if we didn't find anything, leave the template unchanged. But that leads\n    to both a lot of extra build-time expense (since we are attempting\n    resolution for lots of things that may in fact be just some data and not a\n    component invocation at all, and also since we are pre-resolving modules\n    that will get resolved a second time by the final stage packager).\n\n    Now, we're going to be less forgiving, because it streamlines the build for\n    everyone who's not still using these *extremely* old patterns.\n\n    The problematic case is:\n\n      1. In a non-strict template (because this whole resolver-transform.ts is a\n         no-op on strict handlebars).\n\n      2. Have a mustache statement like: `{{something}}`, where `something` is:\n\n        a. Not a variable in scope (for example, there's no preceeding line \n           like `<Parent as |something|>`)\n        b. Does not start with `@` because that must be an argument from outside this template.\n        c. Does not contain a dot, like `some.thing` (because that case is classically \n           never a global component resolution that we would need to handle)\n        d. Does not start with `this` (this rule is mostly redundant with the previous rule, \n           but even a standalone `this` is never a component invocation).\n        e. Does not have any arguments. If there are argument like `{{something a=b}}`, \n           there is still ambiguity between helper vs component, but there is no longer \n           the possibility that this was just rendering some data.\n        f. Does not take a block, like `{{#something}}{{/something}}` (because that is \n           always a component, no ambiguity.)\n\n    We can't tell if this problematic case is really:\n\n      1. A helper invocation with no arguments that is being directly rendered.\n         Out-of-the-box, ember already generates [a lint\n         error](https://github.com/ember-template-lint/ember-template-lint/blob/master/docs/rule/no-curly-component-invocation.md)\n         for this, although it tells you to whitelist your helper when IMO it\n         should tell you to use an unambiguous syntax like `{{ (something) }}`\n         instead.\n\n      2. A component invocation, which you could have written `<Something />`\n         instead. Angle-bracket invocation has been available and easy-to-adopt\n         for a very long time. \n\n      3. Property-this-fallback for `{{this.something}}`. Property-this-fallback\n         is eliminated at Ember 4.0, so people have been heavily pushed to get\n         it out of their addons.\n    */\n\n    // first, bail out on all the stuff we can obviously ignore\n    if (\n      (!this.staticHelpersEnabled && !this.staticComponentsEnabled) ||\n      builtInKeywords.includes(path) ||\n      this.isIgnoredComponent(path)\n    ) {\n      return null;\n    }\n\n    let ownComponentRules = this.findRules(this.env.filename);\n    if (ownComponentRules?.disambiguate[path]) {\n      switch (ownComponentRules.disambiguate[path]) {\n        case 'component':\n          return this.targetComponent(path);\n        case 'helper':\n          return this.targetHelper(path);\n        case 'data':\n          return null;\n      }\n    }\n\n    if (!hasArgs && !path.includes('/') && !path.includes('@')) {\n      // this is the case that could also be property-this-fallback. We're going\n      // to force people to disambiguate, because letting a potential component\n      // or helper invocation lurk inside every bit of data you render is not\n      // ok.\n      this.reportError({\n        type: 'error',\n        message: 'unsupported ambiguous syntax',\n        detail: `\"{{${path}}}\" is ambiguous and could mean \"{{this.${path}}}\" or component \"<${capitalize(\n          camelCase(path)\n        )} />\" or helper \"{{ (${path}) }}\". Change it to one of those unambigous forms, or use a \"disambiguate\" packageRule to work around the problem if its in third-party code you cannot easily fix.`,\n        loc,\n      });\n      return null;\n    }\n\n    // Above we already bailed out if both of these were disabled, so we know at\n    // least one is turned on. If both aren't turned on, we're stuck, because we\n    // can't even tell if this *is* a component vs a helper.\n    if (!this.staticHelpersEnabled || !this.staticComponentsEnabled) {\n      this.reportError({\n        type: 'error',\n        message: 'unsupported ambiguity between helper and component',\n        detail: `this use of \"{{${path}}}\" could be helper \"{{ (${path}) }}\" or component \"<${capitalize(\n          camelCase(path)\n        )} />\", and your settings for staticHelpers and staticComponents do not agree. Either switch to one of the unambiguous forms, or make staticHelpers and staticComponents agree, or use a \"disambiguate\" packageRule to work around the problem if its in third-party code you cannot easily fix.`,\n        loc,\n      });\n      return null;\n    }\n\n    let componentRules = this.rules.components.get(path);\n    return {\n      type: 'component',\n      specifier: `#embroider_compat/ambiguous/${path}`,\n      yieldsComponents: componentRules ? componentRules.yieldsSafeComponents : [],\n      yieldsArguments: componentRules ? componentRules.yieldsArguments : [],\n      argumentsAreComponents: componentRules ? componentRules.argumentsAreComponents : [],\n      nameHint: this.nameHint(path),\n    };\n  }\n\n  private targetElementModifier(path: string): ModifierResolution | null {\n    if (!this.staticModifiersEnabled) {\n      return null;\n    }\n    if (builtInKeywords.includes(path)) {\n      return null;\n    }\n\n    return {\n      type: 'modifier',\n      specifier: `#embroider_compat/modifiers/${path}`,\n      nameHint: this.nameHint(path),\n    };\n  }\n\n  targetDynamicModifier(modifier: ComponentLocator, loc: Loc): ModifierResolution | ResolutionFail | null {\n    if (!this.staticModifiersEnabled) {\n      return null;\n    }\n\n    if (modifier.type === 'literal') {\n      return this.targetElementModifier(modifier.path);\n    } else {\n      return {\n        type: 'error',\n        message: 'Unsafe dynamic modifier',\n        detail: `cannot statically analyze this expression`,\n        loc,\n      };\n    }\n  }\n\n  private targetDynamicHelper(helper: ComponentLocator): HelperResolution | null {\n    if (!this.staticHelpersEnabled) {\n      return null;\n    }\n\n    if (helper.type === 'literal') {\n      return this.targetHelper(helper.path);\n    }\n\n    // we don't have to manage any errors in this case because ember itself\n    // considers it an error to pass anything but a string literal to the\n    // `helper` helper.\n    return null;\n  }\n\n  private nameHint(path: string) {\n    let parts = path.split('@');\n\n    // the extra underscore here guarantees that we will never collide with an\n    // HTML element.\n    return parts[parts.length - 1] + '_';\n  }\n\n  private handleDynamicModifier(param: ASTv1.Expression): ModifierResolution | ResolutionFail | null {\n    if (param.type === 'StringLiteral') {\n      return this.targetDynamicModifier({ type: 'literal', path: param.value }, param.loc);\n    }\n    // we don't have to manage any errors in this case because ember itself\n    // considers it an error to pass anything but a string literal to the\n    // modifier helper.\n    return null;\n  }\n\n  private handleDynamicHelper(param: ASTv1.Expression): HelperResolution | ResolutionFail | null {\n    // We only need to handle StringLiterals since Ember already throws an error if unsupported values\n    // are passed to the helper keyword.\n    // If a helper reference is passed in we don't need to do anything since it's either the result of a previous\n    // helper keyword invocation, or a helper reference that was imported somewhere.\n    if (param.type === 'StringLiteral') {\n      return this.targetDynamicHelper({ type: 'literal', path: param.value });\n    }\n    return null;\n  }\n\n  visitor: ASTPlugin['visitor'] = {\n    Template: {\n      enter: () => {\n        if (this.env.locals) {\n          this.scopeStack.pushMustacheBlock(this.env.locals);\n        }\n      },\n      exit: () => {\n        if (this.env.locals) {\n          this.scopeStack.pop();\n        }\n      },\n    },\n    Block: {\n      enter: node => {\n        this.scopeStack.pushMustacheBlock(node.blockParams);\n      },\n      exit: () => {\n        this.scopeStack.pop();\n      },\n    },\n    BlockStatement: (node, path) => {\n      if (node.path.type !== 'PathExpression') {\n        return;\n      }\n      let rootName = node.path.parts[0];\n      if (this.scopeStack.inScope(rootName, path)) {\n        return;\n      }\n      if (node.path.this === true) {\n        return;\n      }\n      if (node.path.parts.length > 1) {\n        // paths with a dot in them (which therefore split into more than\n        // one \"part\") are classically understood by ember to be contextual\n        // components, which means there's nothing to resolve at this\n        // location.\n        return;\n      }\n      if (node.path.original === 'component' && node.params.length > 0) {\n        let resolution = this.handleComponentHelper(node.params[0]);\n        this.emit(path, resolution, (node, newIdentifier) => {\n          node.params[0] = newIdentifier;\n        });\n        return;\n      }\n      let resolution = this.targetComponent(node.path.original);\n      this.emit(path, resolution, (node, newId) => {\n        node.path = newId;\n      });\n      if (resolution?.type === 'component') {\n        this.scopeStack.enteringComponentBlock(resolution, ({ argumentsAreComponents }) => {\n          this.handleDynamicComponentArguments(\n            rootName,\n            argumentsAreComponents,\n            extendPath(extendPath(path, 'hash'), 'pairs')\n          );\n        });\n      }\n    },\n    SubExpression: (node, path) => {\n      if (node.path.type !== 'PathExpression') {\n        return;\n      }\n      if (node.path.this === true) {\n        return;\n      }\n      if (this.scopeStack.inScope(node.path.parts[0], path)) {\n        return;\n      }\n      if (node.path.original === 'component' && node.params.length > 0) {\n        let resolution = this.handleComponentHelper(node.params[0]);\n        this.emit(path, resolution, (node, newId) => {\n          node.params[0] = newId;\n        });\n        return;\n      }\n      if (node.path.original === 'helper' && node.params.length > 0) {\n        let resolution = this.handleDynamicHelper(node.params[0]);\n        this.emit(path, resolution, (node, newId) => {\n          node.params[0] = newId;\n        });\n        return;\n      }\n      if (node.path.original === 'modifier' && node.params.length > 0) {\n        let resolution = this.handleDynamicModifier(node.params[0]);\n        this.emit(path, resolution, (node, newId) => {\n          node.params[0] = newId;\n        });\n        return;\n      }\n      if (node.path.tail.length === 0 && node.path.head.type === 'VarHead') {\n        let resolution = this.targetHelper(node.path.original);\n        this.emit(path, resolution, (node, newId) => {\n          node.path = newId;\n        });\n      }\n    },\n    MustacheStatement: {\n      enter: (node, path) => {\n        if (node.path.type !== 'PathExpression') {\n          return;\n        }\n        let rootName = node.path.parts[0];\n        if (this.scopeStack.inScope(rootName, path)) {\n          return;\n        }\n        if (node.path.this === true) {\n          return;\n        }\n        if (node.path.parts.length > 1) {\n          // paths with a dot in them (which therefore split into more than\n          // one \"part\") are classically understood by ember to be contextual\n          // components, which means there's nothing to resolve at this\n          // location.\n          return;\n        }\n        if (node.path.original.startsWith('@')) {\n          // similarly, global resolution of helpers and components never\n          // happens with argument paths (it could still be an invocation, but\n          // it would be a lexically-scoped invocation, not one we need to\n          // adjust)\n          return;\n        }\n        if (node.path.original === 'component' && node.params.length > 0) {\n          let resolution = this.handleComponentHelper(node.params[0]);\n          this.emit(path, resolution, (node, newId) => {\n            node.params[0] = newId;\n          });\n          return;\n        }\n        if (node.path.original === 'helper' && node.params.length > 0) {\n          let resolution = this.handleDynamicHelper(node.params[0]);\n          this.emit(path, resolution, (node, newIdentifier) => {\n            node.params[0] = newIdentifier;\n          });\n          return;\n        }\n        if (path.parent?.node.type === 'AttrNode') {\n          // this mustache is the value of an attribute. Components aren't\n          // allowed here, so we're not ambiguous, so resolve a helper.\n          let resolution = this.targetHelper(node.path.original);\n          this.emit(path, resolution, (node, newIdentifier) => {\n            node.path = newIdentifier;\n          });\n          return;\n        }\n        let hasArgs = node.params.length > 0 || node.hash.pairs.length > 0;\n        let resolution = this.targetHelperOrComponent(node.path.original, node.path.loc, hasArgs);\n        this.emit(path, resolution, (node, newIdentifier) => {\n          node.path = newIdentifier;\n        });\n        if (resolution?.type === 'component') {\n          this.handleDynamicComponentArguments(\n            node.path.original,\n            resolution.argumentsAreComponents,\n            extendPath(extendPath(path, 'hash'), 'pairs')\n          );\n        }\n      },\n    },\n    ElementModifierStatement: (node, path) => {\n      if (node.path.type !== 'PathExpression') {\n        return;\n      }\n      if (this.scopeStack.inScope(node.path.parts[0], path)) {\n        return;\n      }\n      if (node.path.this === true) {\n        return;\n      }\n      if (node.path.data === true) {\n        return;\n      }\n      if (node.path.parts.length > 1) {\n        // paths with a dot in them (which therefore split into more than\n        // one \"part\") are classically understood by ember to be contextual\n        // components. With the introduction of `Template strict mode` in Ember 3.25\n        // it is also possible to pass modifiers this way which means there's nothing\n        // to resolve at this location.\n        return;\n      }\n\n      let resolution = this.targetElementModifier(node.path.original);\n      this.emit(path, resolution, (node, newId) => {\n        node.path = newId;\n      });\n    },\n    ElementNode: {\n      enter: (node, path) => {\n        let rootName = node.tag.split('.')[0];\n        if (!this.scopeStack.inScope(rootName, path)) {\n          let resolution: ComponentResolution | null = null;\n\n          // if it starts with lower case, it can't be a component we need to\n          // globally resolve\n          if (node.tag[0] !== node.tag[0].toLowerCase()) {\n            resolution = this.targetComponent(dasherize(node.tag));\n          }\n\n          this.emit(path, resolution, (node, newId) => {\n            node.tag = newId.original;\n          });\n          if (resolution?.type === 'component') {\n            this.scopeStack.enteringComponentBlock(resolution, ({ argumentsAreComponents }) => {\n              this.handleDynamicComponentArguments(node.tag, argumentsAreComponents, extendPath(path, 'attributes'));\n            });\n          }\n        }\n        this.scopeStack.pushElementBlock(node.blockParams, node);\n      },\n      exit: () => {\n        this.scopeStack.pop();\n      },\n    },\n  };\n}\n\n// This is the AST transform that resolves components, helpers and modifiers at build time\nexport default function makeResolverTransform({ appRoot }: Options) {\n  let config: CompatResolverOptions = readJSONSync(join(locateEmbroiderWorkingDir(appRoot), 'resolver.json'));\n  const resolverTransform: ASTPluginBuilder<Env> = env => {\n    if (env.strictMode) {\n      return {\n        name: 'embroider-build-time-resolver-strict-noop',\n        visitor: {},\n      };\n    }\n    return new TemplateResolver(env, config);\n  };\n  (resolverTransform as any).parallelBabel = {\n    requireFile: __filename,\n    buildUsing: 'makeResolverTransform',\n    params: { appRoot: appRoot },\n  };\n  return resolverTransform;\n}\n\ninterface ComponentBlockMarker {\n  type: 'componentBlockMarker';\n  resolution: ComponentResolution;\n  argumentsAreComponents: string[];\n  exit: (marker: ComponentBlockMarker) => void;\n}\n\ntype ScopeEntry =\n  | { type: 'mustache'; blockParams: string[] }\n  | { type: 'element'; blockParams: string[]; childrenOf: ASTv1.ElementNode }\n  | ComponentBlockMarker;\n\nclass ScopeStack {\n  private stack: ScopeEntry[] = [];\n\n  // mustache blocks like:\n  //\n  //   {{#stuff as |some block vars|}}\n  //\n  // are relatively simple for us because there's a dedicated `Block` AST node\n  // that exactly covers the range in which the variables are in scope.\n  pushMustacheBlock(blockParams: string[]) {\n    this.stack.unshift({ type: 'mustache', blockParams });\n  }\n\n  // element blocks like:\n  //\n  //  <Stuff as |some block vars|>\n  //\n  // are *not* so simple for us because there's no single AST node that exactly\n  // covers the range in which the variables are in scope. For example, the\n  // *attributes* of the element do not see the variables, but the children of\n  // the element do.\n  pushElementBlock(blockParams: string[], childrenOf: ASTv1.ElementNode) {\n    this.stack.unshift({ type: 'element', blockParams, childrenOf });\n  }\n\n  // and when we leave the block they go out of scope. If this block was tagged\n  // by a safe component marker, we also clear that.\n  pop() {\n    this.stack.shift();\n    let next = this.stack[0];\n    if (next && next.type === 'componentBlockMarker') {\n      next.exit(next);\n      this.stack.shift();\n    }\n  }\n\n  // right before we enter a block, we might determine that some of the values\n  // that will be yielded as marked (by a rule) as safe to be used with the\n  // {{component}} helper.\n  enteringComponentBlock(resolution: ComponentResolution, exit: ComponentBlockMarker['exit']) {\n    this.stack.unshift({\n      type: 'componentBlockMarker',\n      resolution,\n      argumentsAreComponents: resolution.argumentsAreComponents.slice(),\n      exit,\n    });\n  }\n\n  inScope(name: string, fromPath: WalkerPath<ASTv1.Node>) {\n    for (let scope of this.stack) {\n      if (scope.type === 'mustache' && scope.blockParams.includes(name)) {\n        return true;\n      }\n      if (\n        scope.type === 'element' &&\n        scope.blockParams.includes(name) &&\n        withinElementBlock(fromPath, scope.childrenOf)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  safeComponentInScope(name: string): boolean {\n    let parts = name.split('.');\n    if (parts.length > 2) {\n      // we let component rules specify that they yield components or objects\n      // containing components. But not deeper than that. So the max path length\n      // that can refer to a marked-safe component is two segments.\n      return false;\n    }\n    for (let i = 0; i < this.stack.length - 1; i++) {\n      let here = this.stack[i];\n      let next = this.stack[i + 1];\n      if ((here.type === 'mustache' || here.type === 'element') && next.type === 'componentBlockMarker') {\n        let positionalIndex = here.blockParams.indexOf(parts[0]);\n        if (positionalIndex === -1) {\n          continue;\n        }\n\n        if (parts.length === 1) {\n          if (next.resolution.yieldsComponents[positionalIndex] === true) {\n            return true;\n          }\n          let sourceArg = next.resolution.yieldsArguments[positionalIndex];\n          if (typeof sourceArg === 'string') {\n            next.argumentsAreComponents.push(sourceArg);\n            return true;\n          }\n        } else {\n          let entry = next.resolution.yieldsComponents[positionalIndex];\n          if (entry && typeof entry === 'object') {\n            return entry[parts[1]] === true;\n          }\n\n          let argsEntry = next.resolution.yieldsArguments[positionalIndex];\n          if (argsEntry && typeof argsEntry === 'object') {\n            let sourceArg = argsEntry[parts[1]];\n            if (typeof sourceArg === 'string') {\n              next.argumentsAreComponents.push(sourceArg);\n              return true;\n            }\n          }\n        }\n        // we found the source of the name, but there were no rules to cover it.\n        // Don't keep searching higher, those are different names.\n        return false;\n      }\n    }\n    return false;\n  }\n}\n\nfunction extendPath<N extends ASTv1.Node, K extends keyof N>(\n  path: WalkerPath<N>,\n  key: K\n): N[K] extends ASTv1.Node ? WalkerPath<N[K]> : N[K] extends ASTv1.Node[] ? WalkerPath<N[K][0]>[] : never {\n  const _WalkerPath = path.constructor as {\n    new <Child extends ASTv1.Node>(\n      node: Child,\n      parent?: WalkerPath<ASTv1.Node> | null,\n      parentKey?: string | null\n    ): WalkerPath<Child>;\n  };\n  let child = path.node[key];\n  if (Array.isArray(child)) {\n    return child.map(c => new _WalkerPath(c, path, key as string)) as any;\n  } else {\n    return new _WalkerPath(child as any, path, key as string) as any;\n  }\n}\n\nfunction capitalize(word: string): string {\n  return word[0].toUpperCase() + word.slice(1);\n}\n\n// ElementNodes have both children and attributes and both of those are\n// \"children\" in the abstract syntax tree sense, but here we want to distinguish\n// between them.\nfunction withinElementBlock(childPath: WalkerPath<ASTv1.Node>, ancestorNode: ASTv1.ElementNode): Boolean {\n  let cursor: WalkerPath<ASTv1.Node> | null = childPath;\n  while (cursor && cursor.node !== ancestorNode) {\n    if (ancestorNode.children.includes(cursor.node as ASTv1.Statement)) {\n      return true;\n    }\n    cursor = cursor.parent;\n  }\n  return false;\n}\nfunction appendArrays(objValue: any, srcValue: any) {\n  if (Array.isArray(objValue)) {\n    return objValue.concat(srcValue);\n  }\n}\n"]}