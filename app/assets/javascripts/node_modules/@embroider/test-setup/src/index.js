"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.embroiderOptimized = exports.embroiderSafe = exports.maybeEmbroider = void 0;
// eslint-disable-next-line @typescript-eslint/no-require-imports
const ourPeerDeps = require('../package.json').peerDependencies;
const embroiderDevDeps = {
    '@embroider/core': `${ourPeerDeps['@embroider/core']}`,
    '@embroider/webpack': `${ourPeerDeps['@embroider/webpack']}`,
    '@embroider/compat': `${ourPeerDeps['@embroider/compat']}`,
    // Webpack is a peer dependency of `@embroider/webpack`
    webpack: '^5.0.0',
};
/*
  Use this instead of `app.toTree()` in your ember-cli-build.js:

    return maybeEmbroider(app);

*/
function maybeEmbroider(app, opts = {}) {
    if (!shouldUseEmbroider(app)) {
        return app.toTree(opts === null || opts === void 0 ? void 0 : opts.extraPublicTrees);
    }
    // we're using `require` here on purpose because
    //  - we don't want to load any of these things until they're actually needed;
    //  - we can't use `await import()` because this function needs to be synchronous to go inside ember-cli-build.js
    /* eslint-disable @typescript-eslint/no-require-imports */
    let { Webpack } = require(require.resolve('@embroider/webpack', {
        paths: [app.project.root],
        // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    }));
    let Compat = require(require.resolve('@embroider/compat', {
        paths: [app.project.root],
        // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    }));
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    let mergeWith = require('lodash/mergeWith');
    /* eslint-enable @typescript-eslint/no-require-imports */
    if (process.env.EMBROIDER_TEST_SETUP_OPTIONS) {
        let scenario = Compat.recommendedOptions[process.env.EMBROIDER_TEST_SETUP_OPTIONS];
        if (scenario) {
            opts = mergeWith({}, scenario, opts, appendArrays);
            console.log(`Successfully applied EMBROIDER_TEST_SETUP_OPTIONS=${process.env.EMBROIDER_TEST_SETUP_OPTIONS}`);
        }
        else {
            throw new Error(`No such scenario EMBROIDER_TEST_SETUP_OPTIONS=${process.env.EMBROIDER_TEST_SETUP_OPTIONS}`);
        }
    }
    return Compat.compatBuild(app, Webpack, opts);
}
exports.maybeEmbroider = maybeEmbroider;
function embroiderSafe(extension) {
    return extendScenario({
        name: 'embroider-safe',
        npm: {
            devDependencies: embroiderDevDeps,
        },
        env: {
            EMBROIDER_TEST_SETUP_OPTIONS: 'safe',
        },
    }, extension);
}
exports.embroiderSafe = embroiderSafe;
function embroiderOptimized(extension) {
    return extendScenario({
        name: 'embroider-optimized',
        npm: {
            devDependencies: embroiderDevDeps,
        },
        env: {
            EMBROIDER_TEST_SETUP_OPTIONS: 'optimized',
        },
    }, extension);
}
exports.embroiderOptimized = embroiderOptimized;
function extendScenario(scenario, extension) {
    // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/consistent-type-imports
    let mergeWith = require('lodash/mergeWith');
    return mergeWith(scenario, extension, appendArrays);
}
function appendArrays(objValue, srcValue) {
    if (Array.isArray(objValue)) {
        return objValue.concat(srcValue);
    }
}
function shouldUseEmbroider(app) {
    if (process.env.EMBROIDER_TEST_SETUP_FORCE === 'classic') {
        return false;
    }
    if (process.env.EMBROIDER_TEST_SETUP_FORCE === 'embroider') {
        return true;
    }
    return '@embroider/core' in app.dependencies();
}
//# sourceMappingURL=index.js.map