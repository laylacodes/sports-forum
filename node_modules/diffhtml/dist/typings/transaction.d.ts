export const defaultTasks: (typeof syncTrees)[];
export namespace tasks {
    export { shouldUpdate };
    export { reconcileTrees };
    export { syncTrees };
    export { patchNode };
    export { endAsTransaction };
}
export default class Transaction {
    /**
     * This abstracts away the concept of `new` in case in the future we want
     * to migrate a Transaction off of a class.
     *
     * @param {Mount} mount
     * @param {ValidInput} input
     * @param {TransactionConfig} options
     */
    static create(mount: Mount, input: ValidInput, options: TransactionConfig): Transaction;
    /**
     * @param {Transaction} transaction
     * @param {any} tasks
     *
     * @return {Transaction}
     */
    static flow(transaction: Transaction, tasks: any): Transaction;
    /**
     *
     * @param {Transaction} transaction
     */
    static assert(transaction: Transaction): void;
    /**
     *
     * @param {Transaction} transaction
     */
    static invokeMiddleware(transaction: Transaction): void;
    /**
     * @constructor
     * @param {Mount} mount
     * @param {ValidInput} input
     * @param {TransactionConfig} config
     */
    constructor(mount: Mount, input: ValidInput, config: TransactionConfig);
    /** @type {Mount} */
    mount: Mount;
    /** @type {ValidInput} */
    input: ValidInput;
    config: import("./util/types").TransactionConfig;
    /** @type {TransactionState} */
    state: TransactionState;
    /** @type {Function[]} */
    tasks: Function[];
    endedCallbacks: Set<any>;
    /**
     * @return {Transaction | unknown}
     */
    start(): Transaction | unknown;
    aborted: boolean | undefined;
    /**
     * This will immediately call the last flow task and terminate the flow. We
     * call the last task to ensure that the control flow completes. This should
     * end pseudo-synchronously. Think `Promise.resolve()`, `callback()`, and
     * `return someValue` to provide the most accurate performance reading. This
     * doesn't matter practically besides that.
     *
     * @param {boolean=} isReturn
     */
    abort(isReturn?: boolean | undefined): any;
    /**
     * @return {Transaction}
     */
    end(): Transaction;
    completed: boolean | undefined;
    /**
     * @param {Function} callback
     */
    onceEnded(callback: Function): void;
    /** @type {VTree=} */
    oldTree: VTree | undefined;
    /** @type {VTree=} */
    newTree: VTree | undefined;
    /** @type any */
    patches: any;
}
export type ValidInput = import('./util/types').ValidInput;
export type TransactionConfig = import('./util/types').TransactionConfig;
export type TransactionState = import('./util/types').TransactionState;
export type VTree = import('./util/types').VTree;
export type Mount = import('./util/types').Mount;
import syncTrees from "./tasks/sync-trees";
import shouldUpdate from "./tasks/should-update";
import reconcileTrees from "./tasks/reconcile-trees";
import patchNode from "./tasks/patch-node";
import endAsTransaction from "./tasks/end-as-transaction";
