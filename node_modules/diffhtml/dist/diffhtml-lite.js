(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.diff = {}));
})(this, (function (exports) { 'use strict';

  const NODE_TYPE={ELEMENT:1,ATTR:2,TEXT:3,COMMENT:8,FRAGMENT:11};const EMPTY={STR:"",NUM:1,OBJ:{},ARR:[],MAP:new Map,SET:new Set,DOM:{},FUN:()=>{}};const PATCH_TYPE={SET_ATTRIBUTE:0,REMOVE_ATTRIBUTE:1,NODE_VALUE:2,INSERT_BEFORE:3,REPLACE_CHILD:4,REMOVE_CHILD:5};const StateCache=new Map;const NodeCache=new Map;const MiddlewareCache=new Set;const CreateTreeHookCache=new Set;const CreateNodeHookCache=new Set;const SyncTreeHookCache=new Set;const ReleaseHookCache=new Set;const ParseHookCache=new Set;

  var internalProcess = {env:{NODE_ENV:"production"}};

  var globalThis = typeof global==="object"?global:(typeof window==="object"?window:self)||{};

  const{parseInt}=Number;const{parse}=JSON;const globalConfig={collectMetrics:true,executeScripts:true};function formatValue(value,type){const valueAsString=String(value);switch(type){case"boolean":{return valueAsString!=="false"}case"string":{return valueAsString}case"number":{return parseInt(valueAsString,10)}case"object":{return parse(valueAsString)}}}function getConfig(name,defaultValue,type=typeof defaultValue,overrides){const{location,URLSearchParams}=globalThis;const hasSearchParams=typeof URLSearchParams!=="undefined";const hasLocation=typeof location!=="undefined";const useSearchParams=hasSearchParams&&hasLocation;const useEnv=internalProcess.env;if(overrides&&name in overrides){return overrides[name]}const keyName=`DIFF_${name.replace(/[^a-zA-Z0-9]/,"")}`;if(useSearchParams){const searchParams=new URLSearchParams(location.search);const lowerKey=keyName.toLowerCase();if(searchParams.has(lowerKey)){return formatValue(decodeURIComponent(String(searchParams.get(lowerKey))),type)}}const upperKey=keyName.toUpperCase();if(useEnv&&upperKey in internalProcess.env){return formatValue(internalProcess.env[upperKey.toUpperCase()],type)}return defaultValue}

  const size=getConfig("initialPoolSize",5000);const free=new Set;const allocate=new Set;const protect$1=new Set;const shape=()=>({rawNodeName:EMPTY.STR,nodeName:EMPTY.STR,nodeValue:EMPTY.STR,nodeType:NODE_TYPE.ELEMENT,key:EMPTY.STR,childNodes:[],attributes:{}});const memory$3={free,allocated:allocate,protected:protect$1};let freeValues=free.values();const Pool={size,memory: memory$3,fill(){for(let i=free.size;i<this.size;i++){free.add(shape());}if(this.size<free.size){free.forEach(value=>{if(free.size!==this.size){free.delete(value);}});}},get(){const{value=shape(),done}=freeValues.next();if(done){freeValues=free.values();}free.delete(value);allocate.add(value);return value},protect(vTree){allocate.delete(vTree);protect$1.add(vTree);},unprotect(vTree){if(protect$1.has(vTree)||allocate.has(vTree)){protect$1.delete(vTree);allocate.add(vTree);}}};Pool.fill();

  const{isArray}=Array;const{memory: memory$2}=Pool;const fragmentName="#document-fragment";const textName$1="#text";function flatten(vTrees,retVal=[]){for(let i=0;i<vTrees.length;i++){const vTree=vTrees[i];if(vTree&&vTree.rawNodeName===fragmentName){flatten(vTree.childNodes,retVal);}else if(vTree){retVal.push(vTree);}}return retVal}function createTree(input,attributes,childNodes,...rest){let entry=null;if(memory$2.protected.has(input)||memory$2.allocated.has(input)){entry=input;}else if(!input||isArray(input)){const length=input?input.length:0;childNodes=[];for(let i=0;i<length;i++){const hasInput=input&&!input[i];if(hasInput)continue;input&&childNodes.push(input[i]);}entry=createTree(fragmentName,null,childNodes);}if(entry){return entry}const isObject=typeof input==="object";const inputAsHTMLEl=input;if(input&&isObject&&"ownerDocument"in inputAsHTMLEl){const{nodeType}=inputAsHTMLEl;if(nodeType===NODE_TYPE.TEXT){const vTree=createTree(textName$1,inputAsHTMLEl.nodeValue);NodeCache.set(vTree,inputAsHTMLEl);return vTree}attributes={};childNodes=[];const inputAttrs=inputAsHTMLEl.attributes;if(inputAsHTMLEl.nodeType===NODE_TYPE.ELEMENT&&inputAttrs&&inputAttrs.length){for(let i=0;i<inputAttrs.length;i++){const{name,value}=inputAttrs[i];if(value===EMPTY.STR&&name in inputAsHTMLEl){attributes[name]=input[name];continue}attributes[name]=value;}}if(inputAsHTMLEl.nodeType===NODE_TYPE.ELEMENT||inputAsHTMLEl.nodeType===NODE_TYPE.FRAGMENT){childNodes=[];for(let i=0;i<inputAsHTMLEl.childNodes.length;i++){const childNodeElement=inputAsHTMLEl.childNodes[i];childNodes.push(createTree(childNodeElement));}}NodeCache.forEach((domNode,vTree)=>{if(domNode===input){entry=vTree;}});entry=entry||createTree(inputAsHTMLEl.nodeName,attributes,childNodes);entry.attributes={...entry.attributes,...attributes};entry.childNodes=childNodes;NodeCache.set(entry,inputAsHTMLEl);return entry}if(isObject&&!attributes){const{rawNodeName,nodeName,nodeValue,attributes,childNodes,children}=input;const treeName=rawNodeName||nodeName;const vTree=createTree(treeName,attributes||null,children||childNodes);if(nodeValue){vTree.nodeValue=nodeValue;}return vTree}if(rest.length){childNodes=[childNodes,...rest];}entry=Pool.get();const isTextNode=input===textName$1;const isString=typeof input==="string";if(isString){entry.rawNodeName=input;entry.nodeName=entry.rawNodeName.toLowerCase();}else {entry.rawNodeName=input;entry.nodeName=fragmentName;}entry.nodeValue=EMPTY.STR;entry.key=EMPTY.STR;entry.childNodes.length=0;entry.attributes={};const useAttributes=isArray(attributes)||typeof attributes!=="object";const useNodes=useAttributes?attributes:childNodes;const allNodes=flatten(isArray(useNodes)?useNodes:[useNodes]);if(isTextNode){const nodeValue=allNodes.join(EMPTY.STR);entry.nodeType=NODE_TYPE.TEXT;entry.nodeValue=String(nodeValue);return entry}else if(entry.nodeName===fragmentName){entry.nodeType=NODE_TYPE.FRAGMENT;}else if(input==="#comment"){entry.nodeType=NODE_TYPE.COMMENT;}else {entry.nodeType=NODE_TYPE.ELEMENT;}if(useNodes&&allNodes.length&&(!attributes||!attributes.childNodes)){for(let i=0;i<allNodes.length;i++){const newNode=allNodes[i];if(isArray(newNode)){entry.childNodes.push(...newNode);}else if(!newNode){continue}else if(newNode.nodeType===NODE_TYPE.FRAGMENT&&typeof newNode.rawNodeName==="string"){entry.childNodes.push(...newNode.childNodes);}else if(newNode&&typeof newNode==="object"){entry.childNodes.push(createTree(newNode));}else {entry.childNodes.push(createTree(textName$1,null,newNode));}}}if(attributes&&typeof attributes==="object"&&!isArray(attributes)){entry.attributes={...attributes};if(attributes.childNodes){const isObject=typeof attributes.childNodes==="object";entry.childNodes.push(isObject?createTree(attributes.childNodes):createTree(textName$1,attributes.childNodes));}}if(entry.nodeName==="script"&&entry.attributes.src){entry.key=String(entry.attributes.src);}if(entry.attributes&&"key"in entry.attributes){entry.key=String(entry.attributes.key);}if(CreateTreeHookCache.size){CreateTreeHookCache.forEach((fn,retVal)=>{if(retVal=fn(entry)){entry=createTree(retVal);}});}return entry}

  const prefix="diffHTML";const marks=new Map;let count=0;function makeMeasure(transaction){const{mount,input}=transaction;const inputAsVTree=input;const id=count++;if(!getConfig("collectMetrics",false)){return EMPTY.FUN}return name=>{name=`[${id}] ${name}`;const{host}=mount;if(mount&&host){name=`${host.constructor.name} ${name}`;}else if(inputAsVTree&&typeof inputAsVTree.rawNodeName==="function"){name=`${inputAsVTree.rawNodeName.name} ${name}`;}const endName=`${name}-end`;if(marks.has(name)){const prevMark=marks.get(name)||0;const totalMs=(performance.now()-prevMark).toFixed(3);marks.delete(name);performance.mark(endName);performance.measure(`${prefix} ${name} (${totalMs}ms)`,name,endName);}else {marks.set(name,performance.now());performance.mark(name);}}}

  const{protect,unprotect,memory}=Pool;function protectVTree(vTree){protect(vTree);if(vTree.childNodes.length){for(let i=0;i<vTree.childNodes.length;i++){protectVTree(vTree.childNodes[i]);}}}function unprotectVTree(vTree){if(vTree.childNodes.length){for(let i=0;i<vTree.childNodes.length;i++){unprotectVTree(vTree.childNodes[i]);}}NodeCache.delete(vTree);unprotect(vTree);}function gc(){memory.allocated.forEach(vTree=>{vTree.attributes={};vTree.childNodes.length=0;vTree.key=EMPTY.STR;memory.free.add(vTree);memory.allocated.delete(vTree);NodeCache.delete(vTree);});}

  var memory$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    protectVTree: protectVTree,
    unprotectVTree: unprotectVTree,
    gc: gc
  });

  function shouldUpdate(transaction){const{mount,input,state:{measure},config:options}=transaction;const prop=options.inner?"innerHTML":"outerHTML";measure("should update");const mountAsHTMLEl=mount;if(typeof input==="string"&&mountAsHTMLEl[prop]===input){return transaction.abort(true)}measure("should update");}

  const hasIdle=typeof requestIdleCallback!=="undefined";let gcTimerId=-1;const scheduleTimeout=fn=>(hasIdle?requestIdleCallback:setTimeout)(fn);const cancelTimeout=id=>(hasIdle?cancelIdleCallback:clearTimeout)(id);function release(mount){if(StateCache.has(mount)){const{mutationObserver,oldTree}=StateCache.get(mount);mutationObserver&&mutationObserver.disconnect();if(oldTree&&!NodeCache.has(oldTree)){ReleaseHookCache.forEach(fn=>fn(oldTree));unprotectVTree(oldTree);}StateCache.delete(mount);}if(!mount){return}const asHTMLElement=mount;if(asHTMLElement.childNodes&&asHTMLElement.childNodes.length){for(let i=0;i<asHTMLElement.childNodes.length;i++){release(asHTMLElement.childNodes[i]);}}if(asHTMLElement.shadowRoot){release(asHTMLElement.shadowRoot);}NodeCache.forEach((domNode,vTree)=>{if(domNode===asHTMLElement){ReleaseHookCache.forEach(fn=>fn(vTree));unprotectVTree(vTree);}});cancelTimeout(gcTimerId);gcTimerId=scheduleTimeout(gc);}

  function reconcileTrees(transaction){const{state,mount,input,config:options}=transaction;const{inner}=options;const mountAsHTMLEl=mount;if(state.mutationObserver&&!state.isDirty){state.isDirty=Boolean(state.mutationObserver.takeRecords().length);}else if(!state.mutationObserver){state.isDirty=false;}if(state.isDirty||!state.oldTree){release(mountAsHTMLEl);if(mountAsHTMLEl.ownerDocument&&state.mutationObserver){state.mutationObserver.observe(mountAsHTMLEl,{subtree:true,childList:true,attributes:true,characterData:true});}state.oldTree=createTree(mountAsHTMLEl);protectVTree(state.oldTree);StateCache.set(mount,state);}const{nodeName,attributes}=state.oldTree;if(!transaction.newTree){transaction.newTree=createTree(input);}const inputAsVTree=transaction.newTree;if(!inner&&inputAsVTree.nodeType===NODE_TYPE.FRAGMENT&&state.oldTree.nodeType!==NODE_TYPE.FRAGMENT){let foundElements=[];for(let i=0;i<inputAsVTree.childNodes.length;i++){const value=inputAsVTree.childNodes[i];const isText=value.nodeType===NODE_TYPE.TEXT;if(!isText||value.nodeValue.trim()){foundElements.push(value);}}if(foundElements.length===1){transaction.newTree=foundElements[0];}else if(foundElements.length>1){transaction.newTree=createTree(inputAsVTree.childNodes);}}transaction.oldTree=state.oldTree;const{oldTree,newTree}=transaction;if(inner&&oldTree&&newTree){const isUnknown=typeof newTree.rawNodeName!=="string";const isFragment=newTree.nodeType===NODE_TYPE.FRAGMENT;const children=isFragment&&!isUnknown?newTree.childNodes:newTree;transaction.newTree=createTree(nodeName,attributes,children);}}

  const{assign: assign$2}=Object;const{max}=Math;const keyNames=["old","new"];const textName="#text";function syncTree(oldTree,newTree,patches=[],state={},transaction=EMPTY.OBJ,attributesOnly){if(!oldTree)oldTree=EMPTY.OBJ;if(!newTree)newTree=EMPTY.OBJ;const{svgElements=new Set}=state;const isEmpty=oldTree===EMPTY.OBJ||attributesOnly;let shortCircuit=null;if(SyncTreeHookCache.size){SyncTreeHookCache.forEach(fn=>{const entry=fn(oldTree,newTree,transaction);if(entry&&entry===oldTree){shortCircuit=patches;}else if(entry===false){shortCircuit=false;}else if(entry){assign$2(newTree,entry);}});}if(shortCircuit!==null||!newTree){return shortCircuit}const oldNodeName=oldTree.nodeName;const newNodeName=newTree.nodeName;const isSVG=newNodeName==="svg"||svgElements.has(newTree);if(newNodeName===textName){if(oldNodeName===textName&&oldTree.nodeValue!==newTree.nodeValue){patches.push(PATCH_TYPE.NODE_VALUE,oldTree,newTree.nodeValue,oldTree.nodeValue);oldTree.nodeValue=newTree.nodeValue;return patches}else if(isEmpty){patches.push(PATCH_TYPE.NODE_VALUE,newTree,newTree.nodeValue,null);return patches}}const newChildNodes=newTree.childNodes||[];if(newTree.nodeType===NODE_TYPE.ELEMENT){const oldAttributes=isEmpty?EMPTY.OBJ:oldTree.attributes;const newAttributes=newTree.attributes||EMPTY.OBJ;for(let key in newAttributes){const value=newAttributes[key];if(key in oldAttributes&&oldAttributes[key]===newAttributes[key]){continue}if(!isEmpty){oldAttributes[key]=value;}if((!oldTree||oldTree.nodeName!=="script")&&newTree.nodeName==="script"&&key==="type"){continue}patches.push(PATCH_TYPE.SET_ATTRIBUTE,isEmpty?newTree:oldTree,key,value);}if(!isEmpty){for(let key in oldAttributes){if(key in newAttributes){continue}patches.push(PATCH_TYPE.REMOVE_ATTRIBUTE,oldTree,key);delete oldAttributes[key];}}}if(attributesOnly){for(let i=0;i<newChildNodes.length;i++){isSVG&&svgElements.add(newChildNodes[i]);syncTree(null,newChildNodes[i],patches,state,transaction,true);}return patches}const keysLookup={old:new Map,new:new Map};for(let i=0;i<keyNames.length;i++){const keyName=keyNames[i];const map=keysLookup[keyName];const vTree=arguments[i];const nodes=vTree&&vTree.childNodes;if(nodes&&nodes.length){for(let i=0;i<nodes.length;i++){const vTree=nodes[i];if(vTree.key){map.set(vTree.key,vTree);}}}}const oldChildNodes=oldTree.childNodes||[];let maxLength=max(newChildNodes.length,oldChildNodes.length);for(let i=0;i<maxLength;i++){const oldChildNode=oldChildNodes&&oldChildNodes[i];const newChildNode=newChildNodes[i];if(isSVG||newChildNode&&newChildNode.nodeName==="svg"){svgElements.add(newChildNode);}if(!newChildNode){if(syncTree(oldChildNode,null,patches,state,transaction,true)===false){newChildNodes.splice(i,0,oldChildNode);}continue}if(!oldChildNode){oldChildNodes.push(newChildNode);syncTree(null,newChildNode,patches,state,transaction,true);patches.push(PATCH_TYPE.INSERT_BEFORE,oldTree,newChildNode,null);continue}const newKey=newChildNode.key;const oldKey=oldChildNode.key;const oldInNew=keysLookup.new.has(oldKey);const newInOld=keysLookup.old.has(newKey);if(oldKey||newKey){if(!oldInNew&&!newInOld){syncTree(oldChildNode,newChildNode,patches,state,transaction,true);patches.push(PATCH_TYPE.REPLACE_CHILD,newChildNode,oldChildNode);continue}else if(!oldInNew){patches.push(PATCH_TYPE.REMOVE_CHILD,oldChildNode);oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode),1);i=i-1;continue}if(newKey!==oldKey){let optimalNewNode=newChildNode;if(newKey&&newInOld){optimalNewNode=keysLookup.old.get(newKey);oldChildNodes.splice(oldChildNodes.indexOf(optimalNewNode),1);}else {optimalNewNode=newChildNode;}syncTree(null,optimalNewNode,patches,state,transaction,true);patches.push(PATCH_TYPE.INSERT_BEFORE,oldTree,optimalNewNode,oldChildNode);oldChildNodes.splice(i,0,optimalNewNode);continue}}const sameType=oldChildNode.nodeName===newChildNode.nodeName;const retVal=syncTree(oldChildNode,newChildNode,patches,state,transaction,!sameType);if(retVal===false){newChildNodes.splice(i,0,oldChildNode);maxLength+=1;continue}if(!sameType){oldChildNodes[i]=newChildNode;const lookupIndex=oldChildNodes.lastIndexOf(newChildNode);if(lookupIndex>i){oldChildNodes.splice(lookupIndex,1);}patches.push(PATCH_TYPE.REPLACE_CHILD,newChildNode,oldChildNode);}}if(oldChildNodes.length!==newChildNodes.length){for(let i=newChildNodes.length;i<oldChildNodes.length;i++){patches.push(PATCH_TYPE.REMOVE_CHILD,oldChildNodes[i]);}oldChildNodes.length=newChildNodes.length;}return patches}

  const namespace="http://www.w3.org/2000/svg";function createNode(vTreeLike,ownerDocument=globalThis.document,isSVG){const vTree=createTree(vTreeLike);const existingNode=NodeCache.get(vTree);if(existingNode){return existingNode}const{nodeName,rawNodeName=nodeName,childNodes=[]}=vTree;isSVG=isSVG||nodeName==="svg";let domNodeCheck=null;let retVal=null;CreateNodeHookCache.forEach(fn=>{if(retVal=fn(vTree)){domNodeCheck=retVal;}});if(!ownerDocument){return domNodeCheck}let domNode=domNodeCheck;if(!domNode){if(nodeName==="#comment"){domNode=ownerDocument.createComment(vTree.nodeValue||EMPTY.STR);}else if(nodeName==="#text"){domNode=ownerDocument.createTextNode(vTree.nodeValue||EMPTY.STR);}else if(nodeName==="#document-fragment"){domNode=ownerDocument.createDocumentFragment();}else if(isSVG){domNode=ownerDocument.createElementNS(namespace,rawNodeName);}else {domNode=ownerDocument.createElement(rawNodeName);}if(nodeName==="script"){domNode.type="no-execute";}}NodeCache.set(vTree,domNode);for(let i=0;i<childNodes.length;i++){const validChildNode=createNode(childNodes[i],ownerDocument,isSVG);if(domNode&&validChildNode){domNode.appendChild(validChildNode);}}return domNode}

  function syncTrees(transaction){const{state,state:{measure},oldTree,newTree,mount}=transaction;measure("sync trees");if(oldTree&&newTree&&oldTree.nodeName!==newTree.nodeName&&newTree.nodeType!==NODE_TYPE.FRAGMENT){transaction.patches=[PATCH_TYPE.REPLACE_CHILD,newTree,oldTree];transaction.oldTree=state.oldTree=newTree;const newNode=createNode(newTree);StateCache.delete(mount);StateCache.set(newNode,state);transaction.mount=newNode;if(newTree.nodeName==="script"){state.scriptsToExecute.set(newTree,newTree.attributes.type||EMPTY.STR);}}else {transaction.patches=syncTree(oldTree||null,newTree||null,[],state,transaction);}measure("sync trees");}

  const element$1=globalThis.document?document.createElement("div"):null;function decodeEntities(string){if(!element$1||!string||!string.indexOf||!string.includes("&")){return string}element$1.innerHTML=string;return element$1.textContent||EMPTY.STR}

  const $$insertAfter=Symbol.for("diff.after");const $$diffHTML=Symbol.for("diffHTML");

  const{keys}=Object;const blocklist=new Set;const allowlist=new Set;const setAttribute=(vTree,domNode,name,value)=>{const isObject=typeof value==="object"&&value;const isFunction=typeof value==="function";const isSymbol=typeof value==="symbol";const isEvent=name.indexOf("on")===0;const anyNode=domNode;const lowerName=isEvent?name.toLowerCase():name;const blocklistName="s-"+vTree.nodeName+"-"+lowerName;const htmlElement=domNode;if(allowlist.has(blocklistName)){anyNode[lowerName]=value;}else if(!blocklist.has(blocklistName)){try{anyNode[lowerName]=value;allowlist.add(blocklistName);}catch{blocklist.add(blocklistName);}}if(!isObject&&!isFunction&&!isSymbol){const emptyValue=value===null||value===undefined||value===true;htmlElement.setAttribute(lowerName,emptyValue?EMPTY.STR:value);}else if(isObject&&lowerName==="style"){const valueKeys=keys(value);for(let i=0;i<valueKeys.length;i++){htmlElement.style[valueKeys[i]]=value[valueKeys[i]];}}};const removeAttribute=(vTree,domNode,name)=>{const blocklistName="r-"+vTree.nodeName+"-"+name;const anyNode=domNode;if(allowlist.has(blocklistName)){anyNode[name]=undefined;delete anyNode[name];}else if(!blocklist.has(blocklistName)){try{anyNode[name]=undefined;delete anyNode[name];allowlist.add(blocklistName);}catch{blocklist.add(blocklistName);}}domNode.removeAttribute(name);};function patchNode$1(patches,state=EMPTY.OBJ){const{ownerDocument,svgElements=new Set}=state;const{length}=patches;let i=0;while(true){const patchType=patches[i];if(i===length){break}switch(patchType){case PATCH_TYPE.REMOVE_ATTRIBUTE:case PATCH_TYPE.SET_ATTRIBUTE:{const isSet=patchType===PATCH_TYPE.SET_ATTRIBUTE;const vTree=patches[i+1];const name=patches[i+2];const value=isSet?decodeEntities(patches[i+3]):null;i+=isSet?4:3;const isSVG=svgElements.has(vTree);const domNode=createNode(vTree,ownerDocument,isSVG);protectVTree(vTree);const setOrRemove=isSet?setAttribute:removeAttribute;setOrRemove(vTree,domNode,name,value);break}case PATCH_TYPE.NODE_VALUE:{const vTree=patches[i+1];const nodeValue=patches[i+2];const isSVG=svgElements.has(vTree);i+=4;const domNode=createNode(vTree,ownerDocument,isSVG);protectVTree(vTree);if(nodeValue.includes("&")){domNode.nodeValue=decodeEntities(nodeValue);}else {domNode.nodeValue=nodeValue;}break}case PATCH_TYPE.INSERT_BEFORE:{const vTree=patches[i+1];const newTree=patches[i+2];let refTree=patches[i+3];i+=4;if(!NodeCache.has(vTree)&&vTree!==$$insertAfter){continue}let domNode=NodeCache.get(vTree);if(vTree===$$insertAfter){const refNode=NodeCache.get(refTree);if(refNode){domNode=refNode.parentNode;refTree=refNode.nextSibling?refNode.nextSibling:null;}}const isSVG=svgElements.has(newTree);protectVTree(newTree);const refNode=refTree&&createNode(refTree,ownerDocument,isSVG);const newNode=createNode(newTree,ownerDocument,isSVG);domNode.insertBefore(newNode,refNode||null);break}case PATCH_TYPE.REPLACE_CHILD:{const newTree=patches[i+1];const oldTree=patches[i+2];i+=3;const isSVG=svgElements.has(newTree);const oldDomNode=NodeCache.get(oldTree);const newDomNode=createNode(newTree,ownerDocument,isSVG);if(!oldDomNode||!oldDomNode.parentNode){break}protectVTree(newTree);oldDomNode.parentNode.insertBefore(newDomNode,oldDomNode);oldDomNode.parentNode.removeChild(oldDomNode);unprotectVTree(oldTree);break}case PATCH_TYPE.REMOVE_CHILD:{const vTree=patches[i+1];i+=2;const domNode=NodeCache.get(vTree);if(!domNode||!domNode.parentNode){break}domNode.parentNode.removeChild(domNode);unprotectVTree(vTree);break}}}}

  function patchNode(transaction){const{mount,state,patches}=transaction;const{measure,scriptsToExecute}=state;measure("patch node");const{ownerDocument}=mount;state.ownerDocument=ownerDocument||globalThis.document;const collectScripts=(vTree)=>{if(vTree.nodeName==="script"){scriptsToExecute.set(vTree,vTree.attributes.type);}};CreateNodeHookCache.add(collectScripts);if(state.ownerDocument){patchNode$1(patches,state);}CreateNodeHookCache.delete(collectScripts);measure("patch node");}

  function endAsTransaction(transaction){return transaction.end()}

  const element=globalThis.document?document.createElement("script"):null;function hasModule(){return Boolean(element&&"noModule"in element)}

  const{assign: assign$1}=Object;const defaultTasks=[shouldUpdate,reconcileTrees,syncTrees,patchNode,endAsTransaction];const tasks={shouldUpdate,reconcileTrees,syncTrees,patchNode,endAsTransaction};class Transaction{static create(mount,input,options){return new Transaction(mount,input,options)}static flow(transaction,tasks){let retVal=transaction;for(let i=0;i<tasks.length;i++){if(transaction.aborted){return retVal}retVal=tasks[i](transaction);if(retVal!==undefined&&retVal!==transaction){return retVal}}return retVal}static assert(transaction){}static invokeMiddleware(transaction){const{state:{measure},tasks}=transaction;MiddlewareCache.forEach(fn=>{const label=`invoke ${fn.name||"anon"}`;measure(label);const result=fn(transaction);if(result){tasks.push(result);}measure(label);});}constructor(mount,input,config){this.mount=mount;this.input=input;this.config=config;const useObserver=!config.disableMutationObserver&&"MutationObserver"in(globalThis.window||EMPTY.OBJ);this.state=StateCache.get(mount)||{measure:makeMeasure(this),svgElements:new Set,scriptsToExecute:new Map,mutationObserver:useObserver&&new globalThis.window.MutationObserver(()=>{this.state.isDirty=true;})};this.tasks=getConfig("tasks",defaultTasks,undefined,config).slice();this.endedCallbacks=new Set;StateCache.set(mount,this.state);}start(){const{state:{measure},tasks}=this;const takeLastTask=tasks.pop();measure("render");this.aborted=false;Transaction.invokeMiddleware(this);takeLastTask&&tasks.push(takeLastTask);return Transaction.flow(this,tasks)}abort(isReturn){this.aborted=true;if(isReturn){return this.tasks[this.tasks.length-1](this)}}end(){const{state,config,mount}=this;const{mutationObserver,measure,svgElements,scriptsToExecute}=state;const mountAsHTMLEl=mount;measure("finalize");this.completed=true;svgElements.clear();state.isRendering=false;state.isDirty=false;StateCache.forEach(state=>{if(state.mutationObserver){state.mutationObserver.takeRecords();}});if(mountAsHTMLEl.ownerDocument&&mutationObserver){mutationObserver.observe(mountAsHTMLEl,{subtree:true,childList:true,attributes:true,characterData:true});}else {state.isDirty=true;}scriptsToExecute.forEach((type,vTree)=>{const oldNode=NodeCache.get(vTree);oldNode.type=type;if(!config.executeScripts||hasModule()&&type==="nomodule"){return}const newNode=assign$1(oldNode.ownerDocument.createElement("script"),oldNode);for(let key in vTree.attributes){const value=vTree.attributes[key];newNode.setAttribute(key,value);}newNode.textContent=oldNode.textContent;if(StateCache.has(oldNode)){release(oldNode);StateCache.set(newNode,state);}NodeCache.set(vTree,newNode);oldNode.parentNode&&oldNode.parentNode.replaceChild(newNode,oldNode);});scriptsToExecute.clear();this.endedCallbacks.forEach(callback=>callback(this));this.endedCallbacks.clear();measure("finalize");measure("render");if(state.oldTree)protectVTree(state.oldTree);return this}onceEnded(callback){this.endedCallbacks.add(callback);}state=EMPTY.OBJ;mount=EMPTY.OBJ;input=EMPTY.OBJ;oldTree=undefined;newTree=undefined;tasks=[];patches=[]}

  function escape(unescaped){return unescaped.replace(/[&<>]/g,match=>`&#${match.charCodeAt(0)};`)}

  const caches={StateCache,NodeCache,MiddlewareCache,CreateTreeHookCache,CreateNodeHookCache,SyncTreeHookCache,ReleaseHookCache,ParseHookCache};var internals = {decodeEntities,escape,makeMeasure,memory: memory$1,Pool,process:internalProcess,globalConfig,parse:EMPTY.FUN,PATCH_TYPE,NODE_TYPE,createNode,syncTree,Transaction,defaultTasks,tasks,...caches};

  function innerHTML(mount,input=EMPTY.STR,config={}){config.inner=true;config.executeScripts="executeScripts"in config?config.executeScripts:true;config.tasks=config.tasks||defaultTasks;return Transaction.create(mount,input,config).start()}

  function outerHTML(mount,input=EMPTY.STR,config={}){config.inner=false;config.executeScripts="executeScripts"in config?config.executeScripts:true;config.tasks=config.tasks||defaultTasks;return Transaction.create(mount,input,config).start()}

  function use(middleware){const isFunction=typeof middleware==="function";const{subscribe,unsubscribe,createTreeHook,createNodeHook,syncTreeHook,releaseHook,parseHook}=middleware;isFunction&&MiddlewareCache.add(middleware);subscribe&&subscribe(internals);createTreeHook&&CreateTreeHookCache.add(createTreeHook);createNodeHook&&CreateNodeHookCache.add(createNodeHook);syncTreeHook&&SyncTreeHookCache.add(syncTreeHook);releaseHook&&ReleaseHookCache.add(releaseHook);parseHook&&ParseHookCache.add(parseHook);return ()=>{isFunction&&MiddlewareCache.delete(middleware);unsubscribe&&unsubscribe(internals);createTreeHook&&CreateTreeHookCache.delete(createTreeHook);createNodeHook&&CreateNodeHookCache.delete(createNodeHook);syncTreeHook&&SyncTreeHookCache.delete(syncTreeHook);releaseHook&&ReleaseHookCache.delete(releaseHook);parseHook&&ParseHookCache.delete(parseHook);}}

  const __VERSION__="1.0.0-beta.30";

  const{assign}=Object;const VERSION=`${__VERSION__}-lite`;assign(internals,{VERSION});const api={};api.VERSION=VERSION;api.release=release;api.createTree=createTree;api.use=use;api.outerHTML=outerHTML;api.innerHTML=innerHTML;api.html=createTree;api.Internals=internals;if($$diffHTML in globalThis){const existingApi=globalThis[$$diffHTML];if(VERSION!==existingApi.VERSION){console.log(`Loaded ${VERSION} after ${existingApi.VERSION}`);}}globalThis[$$diffHTML]=api;if(globalThis.devTools){globalThis.unsubscribeDevTools=use(globalThis.devTools(internals));}

  exports.Internals = internals;
  exports.VERSION = VERSION;
  exports.createTree = createTree;
  exports.default = api;
  exports.html = createTree;
  exports.innerHTML = innerHTML;
  exports.outerHTML = outerHTML;
  exports.release = release;
  exports.use = use;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
