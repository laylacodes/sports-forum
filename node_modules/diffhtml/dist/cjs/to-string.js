"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default=toString;var _create=_interopRequireDefault(require("./tree/create"));var _transaction=_interopRequireWildcard(require("./transaction"));var _release=_interopRequireDefault(require("./release"));function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!=="function")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!=="object"&&typeof obj!=="function"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!=="default"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}/**
 * @typedef {import('./util/types').ValidInput} ValidInput
 * @typedef {import('./util/types').TransactionConfig} TransactionConfig
 * @typedef {import('./util/types').VTree} VTree
 * @typedef {import('./util/types').VTreeAttributes} VTreeAttributes
 */const{keys}=Object;/**
 * Renders input to a string.
 *
 * Works like outerHTML by rendering a VTree and returning the source. This
 * will accept any input that `outerHTML` normally accepts. This is a true
 * render, but omits the DOM patching task.
 *
 * @param {ValidInput} input
 * @param {TransactionConfig} config
 * @return {string}
 */function toString(input,config={}){const oldTree=(0,_create.default)();const activeTasks=new Set(config.tasks||_transaction.defaultTasks);activeTasks.delete(_transaction.tasks.patchNode);// Replace the `endAsTransaction` task with the string return value.
activeTasks.delete(_transaction.tasks.endAsTransaction);activeTasks.add(function endAsString(/** @type {Transaction} */transaction){return serializeVTree(transaction.oldTree)});config.tasks=[...activeTasks];config.inner=true;let markup="";try{markup=/** @type {string} */_transaction.default.create(oldTree,input,config).start()}catch(e){(0,_release.default)(oldTree);throw e}(0,_release.default)(oldTree);return markup}/**
 * serializeAttributes
 *
 * Takes in a diffHTML VTree attributes object and turns it into a key=value
 * string.
 *
 * @param {VTreeAttributes} attributes
 * @return {String}
 */function serializeAttributes(attributes){const attrs=keys(attributes);return attrs.length?" "+attrs.map(keyName=>{const value=attributes[keyName];const isFalsy=!value;const isDynamic=typeof value==="object"||typeof value==="function";if(value===true){return keyName}return`${keyName}${!isFalsy&&!isDynamic?`="${String(value)}"`:""}`}).join(" "):""}/**
 * serializeVTree
 *
 * Takes in a diffHTML VTree object and turns it into a string of HTML.
 *
 * @param {VTree=} vTree
 * @return {String}
 */function serializeVTree(vTree){let output="";if(!vTree){return output}const{childNodes,nodeType,nodeName:tag,nodeValue,attributes}=vTree;// Document fragment.
if(nodeType===11){for(let i=0;i<childNodes.length;i++){output+=serializeVTree(childNodes[i])}}// Empty element.
else if(!childNodes.length&&nodeType===1){output+=`<${tag}${serializeAttributes(attributes)}></${tag}>`}// Text Nodes.
else if(nodeType===3){output+=nodeValue}// Presentational DOM Node.
else if(childNodes.length){const children=childNodes.map(childNode=>`${serializeVTree(childNode)}`).join("");output+=`<${tag}${serializeAttributes(attributes)}>${children}</${tag}>`}return output}module.exports=exports.default;